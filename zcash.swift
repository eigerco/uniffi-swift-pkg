// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(zcashFFI)
    import zcashFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_uniffi_zcash_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_uniffi_zcash_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol SecpSecretKeyProtocol {
    func serializeSecret() -> [UInt8]
}

public class SecpSecretKey: SecpSecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_secpsecretkey_new(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_secpsecretkey(pointer, $0) }
    }

    public func serializeSecret() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_secpsecretkey_serialize_secret(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeSecpSecretKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecpSecretKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecpSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecpSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecpSecretKey {
        return SecpSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecpSecretKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeSecpSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecpSecretKey {
    return try FfiConverterTypeSecpSecretKey.lift(pointer)
}

public func FfiConverterTypeSecpSecretKey_lower(_ value: SecpSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecpSecretKey.lower(value)
}

public protocol TestSupportProtocol {
    func getAsString(key: String) -> String

    func getAsU32(key: String) -> UInt32

    func getAsU32Array(key: String) -> [UInt32]

    func getAsU64(key: String) -> UInt64

    func getAsU64Array(key: String) -> [UInt64]

    func getAsU8Array(key: String) -> [UInt8]
}

public class TestSupport: TestSupportProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_testsupport(pointer, $0) }
    }

    public static func fromCsvFile() -> TestSupport {
        return TestSupport(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_testsupport_from_csv_file($0)
        })
    }

    public func getAsString(key: String) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_string(self.pointer,
                                                                            FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU32(key: String) -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32(self.pointer,
                                                                         FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU32Array(key: String) -> [UInt32] {
        return try! FfiConverterSequenceUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32_array(self.pointer,
                                                                               FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU64(key: String) -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64(self.pointer,
                                                                         FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU64Array(key: String) -> [UInt64] {
        return try! FfiConverterSequenceUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64_array(self.pointer,
                                                                               FfiConverterString.lower(key), $0)
                }
        )
    }

    public func getAsU8Array(key: String) -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_testsupport_get_as_u8_array(self.pointer,
                                                                              FfiConverterString.lower(key), $0)
                }
        )
    }
}

public struct FfiConverterTypeTestSupport: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TestSupport

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TestSupport {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TestSupport, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TestSupport {
        return TestSupport(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TestSupport) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeTestSupport_lift(_ pointer: UnsafeMutableRawPointer) throws -> TestSupport {
    return try FfiConverterTypeTestSupport.lift(pointer)
}

public func FfiConverterTypeTestSupport_lower(_ value: TestSupport) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTestSupport.lower(value)
}

public protocol ZcashAccountBalanceProtocol {
    func saplingSpendableValue() -> ZcashNonNegativeAmount

    func total() -> ZcashNonNegativeAmount
}

public class ZcashAccountBalance: ZcashAccountBalanceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashaccountbalance(pointer, $0) }
    }

    public static func zero() -> ZcashAccountBalance {
        return ZcashAccountBalance(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashaccountbalance_zero($0)
        })
    }

    public func saplingSpendableValue() -> ZcashNonNegativeAmount {
        return try! FfiConverterTypeZcashNonNegativeAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountbalance_sapling_spendable_value(self.pointer, $0)
                }
        )
    }

    public func total() -> ZcashNonNegativeAmount {
        return try! FfiConverterTypeZcashNonNegativeAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountbalance_total(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAccountBalance: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAccountBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountBalance {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAccountBalance, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountBalance {
        return ZcashAccountBalance(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAccountBalance) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAccountBalance_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountBalance {
    return try FfiConverterTypeZcashAccountBalance.lift(pointer)
}

public func FfiConverterTypeZcashAccountBalance_lower(_ value: ZcashAccountBalance) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAccountBalance.lower(value)
}

public protocol ZcashAccountPrivKeyProtocol {
    func deriveExternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey

    func deriveInternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey

    func toAccountPubkey() -> ZcashAccountPubKey

    func toBytes() -> [UInt8]
}

public class ZcashAccountPrivKey: ZcashAccountPrivKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashaccountprivkey(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashAccountPrivKey {
        return try ZcashAccountPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func fromExtendedPrivkey(key: ZcashExtendedPrivKey) -> ZcashAccountPrivKey {
        return ZcashAccountPrivKey(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_extended_privkey(
                FfiConverterTypeZcashExtendedPrivKey.lower(key), $0
            )
        })
    }

    public static func fromSeed(params: ZcashConsensusParameters, seed: [UInt8], accountId: ZcashAccountId) throws -> ZcashAccountPrivKey {
        return try ZcashAccountPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_seed(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterSequenceUInt8.lower(seed),
                FfiConverterTypeZcashAccountId.lower(accountId), $0
            )
        })
    }

    public func deriveExternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey {
        return try FfiConverterTypeSecpSecretKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_external_secret_key(self.pointer,
                                                                                             FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func deriveInternalSecretKey(childIndex: UInt32) throws -> SecpSecretKey {
        return try FfiConverterTypeSecpSecretKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_internal_secret_key(self.pointer,
                                                                                             FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func toAccountPubkey() -> ZcashAccountPubKey {
        return try! FfiConverterTypeZcashAccountPubKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_account_pubkey(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAccountPrivKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAccountPrivKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountPrivKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAccountPrivKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPrivKey {
        return ZcashAccountPrivKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAccountPrivKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAccountPrivKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPrivKey {
    return try FfiConverterTypeZcashAccountPrivKey.lift(pointer)
}

public func FfiConverterTypeZcashAccountPrivKey_lower(_ value: ZcashAccountPrivKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAccountPrivKey.lower(value)
}

public protocol ZcashAccountPubKeyProtocol {
    func deriveExternalIvk() throws -> ZcashExternalIvk

    func deriveInternalIvk() throws -> ZcashInternalIvk

    func externalOvk() -> ZcashExternalOvk

    func internalOvk() -> ZcashInternalOvk

    func ovksForShielding() -> ZcashInternalOvkExternalOvk

    func serialize() -> [UInt8]
}

public class ZcashAccountPubKey: ZcashAccountPubKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashaccountpubkey_new(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashaccountpubkey(pointer, $0) }
    }

    public func deriveExternalIvk() throws -> ZcashExternalIvk {
        return try FfiConverterTypeZcashExternalIvk.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_external_ivk(self.pointer, $0)
            }
        )
    }

    public func deriveInternalIvk() throws -> ZcashInternalIvk {
        return try FfiConverterTypeZcashInternalIvk.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_internal_ivk(self.pointer, $0)
            }
        )
    }

    public func externalOvk() -> ZcashExternalOvk {
        return try! FfiConverterTypeZcashExternalOvk.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_external_ovk(self.pointer, $0)
                }
        )
    }

    public func internalOvk() -> ZcashInternalOvk {
        return try! FfiConverterTypeZcashInternalOvk.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_internal_ovk(self.pointer, $0)
                }
        )
    }

    public func ovksForShielding() -> ZcashInternalOvkExternalOvk {
        return try! FfiConverterTypeZcashInternalOvkExternalOvk.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_ovks_for_shielding(self.pointer, $0)
                }
        )
    }

    public func serialize() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_serialize(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAccountPubKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAccountPubKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountPubKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAccountPubKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPubKey {
        return ZcashAccountPubKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAccountPubKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAccountPubKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAccountPubKey {
    return try FfiConverterTypeZcashAccountPubKey.lift(pointer)
}

public func FfiConverterTypeZcashAccountPubKey_lower(_ value: ZcashAccountPubKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAccountPubKey.lower(value)
}

public protocol ZcashAddressMetadataProtocol {
    func account() -> ZcashAccountId

    func diversifierIndex() -> ZcashDiversifierIndex
}

public class ZcashAddressMetadata: ZcashAddressMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(account: ZcashAccountId, diversifierIndex: ZcashDiversifierIndex) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashaddressmetadata_new(
                FfiConverterTypeZcashAccountId.lower(account),
                FfiConverterTypeZcashDiversifierIndex.lower(diversifierIndex), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashaddressmetadata(pointer, $0) }
    }

    public func account() -> ZcashAccountId {
        return try! FfiConverterTypeZcashAccountId.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_account(self.pointer, $0)
                }
        )
    }

    public func diversifierIndex() -> ZcashDiversifierIndex {
        return try! FfiConverterTypeZcashDiversifierIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_diversifier_index(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAddressMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAddressMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAddressMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAddressMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAddressMetadata {
        return ZcashAddressMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAddressMetadata) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAddressMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAddressMetadata {
    return try FfiConverterTypeZcashAddressMetadata.lift(pointer)
}

public func FfiConverterTypeZcashAddressMetadata_lower(_ value: ZcashAddressMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAddressMetadata.lower(value)
}

public protocol ZcashAmountProtocol {
    func value() -> Int64
}

public class ZcashAmount: ZcashAmountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(amount: Int64) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashamount_new(
                FfiConverterInt64.lower(amount), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashamount(pointer, $0) }
    }

    public static func zero() -> ZcashAmount {
        return ZcashAmount(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashamount_zero($0)
        })
    }

    public func value() -> Int64 {
        return try! FfiConverterInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashamount_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAmount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAmount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAmount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAmount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAmount {
        return ZcashAmount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAmount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAmount {
    return try FfiConverterTypeZcashAmount.lift(pointer)
}

public func FfiConverterTypeZcashAmount_lower(_ value: ZcashAmount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAmount.lower(value)
}

public protocol ZcashAnchorProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashAnchor: ZcashAnchorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashanchor(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashAnchor {
        return try ZcashAnchor(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashanchor_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashanchor_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashAnchor: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashAnchor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAnchor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashAnchor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAnchor {
        return ZcashAnchor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashAnchor) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashAnchor_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashAnchor {
    return try FfiConverterTypeZcashAnchor.lift(pointer)
}

public func FfiConverterTypeZcashAnchor_lower(_ value: ZcashAnchor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashAnchor.lower(value)
}

public protocol ZcashBackendScanProtocol {
    func scanCachedBlocks(params: ZcashConsensusParameters, zDbCache: ZcashFsBlockDb, zDbData: ZcashWalletDb, height: ZcashBlockHeight, limit: UInt32) throws
}

public class ZcashBackendScan: ZcashBackendScanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashbackendscan(pointer, $0) }
    }

    public func scanCachedBlocks(params: ZcashConsensusParameters, zDbCache: ZcashFsBlockDb, zDbData: ZcashWalletDb, height: ZcashBlockHeight, limit: UInt32) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashbackendscan_scan_cached_blocks(self.pointer,
                                                                                  FfiConverterTypeZcashConsensusParameters.lower(params),
                                                                                  FfiConverterTypeZcashFsBlockDb.lower(zDbCache),
                                                                                  FfiConverterTypeZcashWalletDb.lower(zDbData),
                                                                                  FfiConverterTypeZcashBlockHeight.lower(height),
                                                                                  FfiConverterUInt32.lower(limit), $0)
            }
    }
}

public struct FfiConverterTypeZcashBackendScan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBackendScan

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBackendScan {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBackendScan, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBackendScan {
        return ZcashBackendScan(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBackendScan) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBackendScan_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBackendScan {
    return try FfiConverterTypeZcashBackendScan.lift(pointer)
}

public func FfiConverterTypeZcashBackendScan_lower(_ value: ZcashBackendScan) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBackendScan.lower(value)
}

public protocol ZcashBalanceProtocol {
    func total() -> ZcashNonNegativeAmount
}

public class ZcashBalance: ZcashBalanceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashbalance(pointer, $0) }
    }

    public static func zero() -> ZcashBalance {
        return ZcashBalance(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashbalance_zero($0)
        })
    }

    public func total() -> ZcashNonNegativeAmount {
        return try! FfiConverterTypeZcashNonNegativeAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashbalance_total(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashBalance: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBalance {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBalance, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBalance {
        return ZcashBalance(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBalance) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBalance_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBalance {
    return try FfiConverterTypeZcashBalance.lift(pointer)
}

public func FfiConverterTypeZcashBalance_lower(_ value: ZcashBalance) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBalance.lower(value)
}

public protocol ZcashBlockHashProtocol {}

public class ZcashBlockHash: ZcashBlockHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashblockhash(pointer, $0) }
    }

    public static func fromSlice(fromBytes: [UInt8]) -> ZcashBlockHash {
        return ZcashBlockHash(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashblockhash_from_slice(
                FfiConverterSequenceUInt8.lower(fromBytes), $0
            )
        })
    }
}

public struct FfiConverterTypeZcashBlockHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBlockHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBlockHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBlockHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHash {
        return ZcashBlockHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBlockHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBlockHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHash {
    return try FfiConverterTypeZcashBlockHash.lift(pointer)
}

public func FfiConverterTypeZcashBlockHash_lower(_ value: ZcashBlockHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBlockHash.lower(value)
}

public protocol ZcashBlockHeightProtocol {
    func value() -> UInt32
}

public class ZcashBlockHeight: ZcashBlockHeightProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(v: UInt32) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashblockheight_new(
                FfiConverterUInt32.lower(v), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashblockheight(pointer, $0) }
    }

    public func value() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashblockheight_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashBlockHeight: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBlockHeight

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBlockHeight {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBlockHeight, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHeight {
        return ZcashBlockHeight(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBlockHeight) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBlockHeight_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockHeight {
    return try FfiConverterTypeZcashBlockHeight.lift(pointer)
}

public func FfiConverterTypeZcashBlockHeight_lower(_ value: ZcashBlockHeight) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBlockHeight.lower(value)
}

public protocol ZcashBlockMetaProtocol {
    func blockFilePath(blocksDir: String) -> String
}

public class ZcashBlockMeta: ZcashBlockMetaProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashblockmeta(pointer, $0) }
    }

    public func blockFilePath(blocksDir: String) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashblockmeta_block_file_path(self.pointer,
                                                                                 FfiConverterString.lower(blocksDir), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashBlockMeta: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashBlockMeta

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBlockMeta {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashBlockMeta, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockMeta {
        return ZcashBlockMeta(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashBlockMeta) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashBlockMeta_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashBlockMeta {
    return try FfiConverterTypeZcashBlockMeta.lift(pointer)
}

public func FfiConverterTypeZcashBlockMeta_lower(_ value: ZcashBlockMeta) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashBlockMeta.lower(value)
}

public protocol ZcashChainProtocol {
    func initBlockmetaDb(blocksDir: String) throws
}

public class ZcashChain: ZcashChainProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashchain(pointer, $0) }
    }

    public func initBlockmetaDb(blocksDir: String) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashchain_init_blockmeta_db(self.pointer,
                                                                           FfiConverterString.lower(blocksDir), $0)
            }
    }
}

public struct FfiConverterTypeZcashChain: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashChain

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashChain {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashChain, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashChain {
        return ZcashChain(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashChain) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashChain_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashChain {
    return try FfiConverterTypeZcashChain.lift(pointer)
}

public func FfiConverterTypeZcashChain_lower(_ value: ZcashChain) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashChain.lower(value)
}

public protocol ZcashCommitmentTreeProtocol {
    func append(node: ZcashSaplingNode) throws
}

public class ZcashCommitmentTree: ZcashCommitmentTreeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashcommitmenttree(pointer, $0) }
    }

    public static func empty() -> ZcashCommitmentTree {
        return ZcashCommitmentTree(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttree_empty($0)
        })
    }

    public func append(node: ZcashSaplingNode) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashcommitmenttree_append(self.pointer,
                                                                         FfiConverterTypeZcashSaplingNode.lower(node), $0)
            }
    }
}

public struct FfiConverterTypeZcashCommitmentTree: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashCommitmentTree

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashCommitmentTree {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashCommitmentTree, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTree {
        return ZcashCommitmentTree(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashCommitmentTree) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashCommitmentTree_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTree {
    return try FfiConverterTypeZcashCommitmentTree.lift(pointer)
}

public func FfiConverterTypeZcashCommitmentTree_lower(_ value: ZcashCommitmentTree) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashCommitmentTree.lower(value)
}

public protocol ZcashCommitmentTreeRootProtocol {
    func rootHash() -> ZcashSaplingNode

    func subtreeEndHeight() -> ZcashBlockHeight
}

public class ZcashCommitmentTreeRoot: ZcashCommitmentTreeRootProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashcommitmenttreeroot(pointer, $0) }
    }

    public static func fromParts(subtreeEndHeight: ZcashBlockHeight, rootHash: ZcashSaplingNode) -> ZcashCommitmentTreeRoot {
        return ZcashCommitmentTreeRoot(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttreeroot_from_parts(
                FfiConverterTypeZcashBlockHeight.lower(subtreeEndHeight),
                FfiConverterTypeZcashSaplingNode.lower(rootHash), $0
            )
        })
    }

    public func rootHash() -> ZcashSaplingNode {
        return try! FfiConverterTypeZcashSaplingNode.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_root_hash(self.pointer, $0)
                }
        )
    }

    public func subtreeEndHeight() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_subtree_end_height(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashCommitmentTreeRoot: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashCommitmentTreeRoot

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashCommitmentTreeRoot {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashCommitmentTreeRoot, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTreeRoot {
        return ZcashCommitmentTreeRoot(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashCommitmentTreeRoot) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashCommitmentTreeRoot_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashCommitmentTreeRoot {
    return try FfiConverterTypeZcashCommitmentTreeRoot.lift(pointer)
}

public func FfiConverterTypeZcashCommitmentTreeRoot_lower(_ value: ZcashCommitmentTreeRoot) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashCommitmentTreeRoot.lower(value)
}

public protocol ZcashDecryptedTransactionProtocol {}

public class ZcashDecryptedTransaction: ZcashDecryptedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashdecryptedtransaction(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashDecryptedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDecryptedTransaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDecryptedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDecryptedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDecryptedTransaction {
        return ZcashDecryptedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDecryptedTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDecryptedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDecryptedTransaction {
    return try FfiConverterTypeZcashDecryptedTransaction.lift(pointer)
}

public func FfiConverterTypeZcashDecryptedTransaction_lower(_ value: ZcashDecryptedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDecryptedTransaction.lower(value)
}

public protocol ZcashDiversifiableFullViewingKeyProtocol {
    func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress?

    func changeAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func decryptDiversifier(addr: ZcashPaymentAddress) -> ZcashDiversifierIndexAndScope?

    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func diversifiedAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func diversifiedChangeAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress?

    func fvk() -> ZcashFullViewingKey

    func toBytes() -> [UInt8]

    func toIvk(scope: ZcashScope) -> ZcashSaplingIvk

    func toNk(scope: ZcashScope) -> ZcashNullifierDerivingKey

    func toOvk(scope: ZcashScope) -> ZcashOutgoingViewingKey
}

public class ZcashDiversifiableFullViewingKey: ZcashDiversifiableFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashdiversifiablefullviewingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashDiversifiableFullViewingKey {
        return try ZcashDiversifiableFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashdiversifiablefullviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_address(self.pointer,
                                                                                           FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func changeAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_change_address(self.pointer, $0)
                }
        )
    }

    public func decryptDiversifier(addr: ZcashPaymentAddress) -> ZcashDiversifierIndexAndScope? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndScope.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_decrypt_diversifier(self.pointer,
                                                                                                       FfiConverterTypeZcashPaymentAddress.lower(addr), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_default_address(self.pointer, $0)
                }
        )
    }

    public func diversifiedAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_address(self.pointer,
                                                                                                       FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func diversifiedChangeAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_change_address(self.pointer,
                                                                                                              FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_find_address(self.pointer,
                                                                                                FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func fvk() -> ZcashFullViewingKey {
        return try! FfiConverterTypeZcashFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_fvk(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toIvk(scope: ZcashScope) -> ZcashSaplingIvk {
        return try! FfiConverterTypeZcashSaplingIvk.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ivk(self.pointer,
                                                                                          FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }

    public func toNk(scope: ZcashScope) -> ZcashNullifierDerivingKey {
        return try! FfiConverterTypeZcashNullifierDerivingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_nk(self.pointer,
                                                                                         FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }

    public func toOvk(scope: ZcashScope) -> ZcashOutgoingViewingKey {
        return try! FfiConverterTypeZcashOutgoingViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ovk(self.pointer,
                                                                                          FfiConverterTypeZcashScope.lower(scope), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDiversifiableFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifiableFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifiableFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifiableFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifiableFullViewingKey {
        return ZcashDiversifiableFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifiableFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifiableFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifiableFullViewingKey {
    return try FfiConverterTypeZcashDiversifiableFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashDiversifiableFullViewingKey_lower(_ value: ZcashDiversifiableFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifiableFullViewingKey.lower(value)
}

public protocol ZcashDiversifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashDiversifier: ZcashDiversifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(bytes: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashdiversifier_new(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashdiversifier(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDiversifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifier {
        return ZcashDiversifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifier {
    return try FfiConverterTypeZcashDiversifier.lift(pointer)
}

public func FfiConverterTypeZcashDiversifier_lower(_ value: ZcashDiversifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifier.lower(value)
}

public protocol ZcashDiversifierIndexProtocol {
    func increment() throws

    func toBytes() -> [UInt8]

    func toU32() throws -> UInt32
}

public class ZcashDiversifierIndex: ZcashDiversifierIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashdiversifierindex(pointer, $0) }
    }

    public static func fromU32(i: UInt32) -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u32(
                FfiConverterUInt32.lower(i), $0
            )
        })
    }

    public static func fromU64(i: UInt64) -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u64(
                FfiConverterUInt64.lower(i), $0
            )
        })
    }

    public func increment() throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_increment(self.pointer, $0)
            }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toU32() throws -> UInt32 {
        return try FfiConverterUInt32.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_u32(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashDiversifierIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDiversifierIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDiversifierIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifierIndex {
        return ZcashDiversifierIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDiversifierIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDiversifierIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDiversifierIndex {
    return try FfiConverterTypeZcashDiversifierIndex.lift(pointer)
}

public func FfiConverterTypeZcashDiversifierIndex_lower(_ value: ZcashDiversifierIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDiversifierIndex.lower(value)
}

public protocol ZcashDustOutputPolicyProtocol {
    func action() -> ZcashDustAction

    func dustThreshold() -> ZcashAmount?
}

public class ZcashDustOutputPolicy: ZcashDustOutputPolicyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(action: ZcashDustAction, dustThreshold: ZcashAmount?) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashdustoutputpolicy_new(
                FfiConverterTypeZcashDustAction.lower(action),
                FfiConverterOptionTypeZcashAmount.lower(dustThreshold), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashdustoutputpolicy(pointer, $0) }
    }

    public func action() -> ZcashDustAction {
        return try! FfiConverterTypeZcashDustAction.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_action(self.pointer, $0)
                }
        )
    }

    public func dustThreshold() -> ZcashAmount? {
        return try! FfiConverterOptionTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_dust_threshold(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashDustOutputPolicy: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashDustOutputPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDustOutputPolicy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashDustOutputPolicy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDustOutputPolicy {
        return ZcashDustOutputPolicy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashDustOutputPolicy) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashDustOutputPolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashDustOutputPolicy {
    return try FfiConverterTypeZcashDustOutputPolicy.lift(pointer)
}

public func FfiConverterTypeZcashDustOutputPolicy_lower(_ value: ZcashDustOutputPolicy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashDustOutputPolicy.lower(value)
}

public protocol ZcashExpandedSpendingKeyProtocol {
    func proofGenerationKey() -> ZcashProofGenerationKey

    func toBytes() -> [UInt8]
}

public class ZcashExpandedSpendingKey: ZcashExpandedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashexpandedspendingkey(pointer, $0) }
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashExpandedSpendingKey {
        return try ZcashExpandedSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(b), $0
            )
        })
    }

    public static func fromSpendingKey(sk: [UInt8]) -> ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_spending_key(
                FfiConverterSequenceUInt8.lower(sk), $0
            )
        })
    }

    public func proofGenerationKey() -> ZcashProofGenerationKey {
        return try! FfiConverterTypeZcashProofGenerationKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_proof_generation_key(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExpandedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExpandedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExpandedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExpandedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExpandedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExpandedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExpandedSpendingKey {
    return try FfiConverterTypeZcashExpandedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashExpandedSpendingKey_lower(_ value: ZcashExpandedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExpandedSpendingKey.lower(value)
}

public protocol ZcashExtendedFullViewingKeyProtocol {
    func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress?

    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func deriveChild(i: ZcashChildIndex) throws -> ZcashExtendedFullViewingKey

    func deriveInternal() -> ZcashExtendedFullViewingKey

    func encode(params: ZcashConsensusParameters) -> String

    func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress?

    func toBytes() -> [UInt8]

    func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey
}

public class ZcashExtendedFullViewingKey: ZcashExtendedFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashextendedfullviewingkey(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashExtendedFullViewingKey {
        return try ZcashExtendedFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(input), $0
            )
        })
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashExtendedFullViewingKey {
        return try ZcashExtendedFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_address(self.pointer,
                                                                                      FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_default_address(self.pointer, $0)
                }
        )
    }

    public func deriveChild(i: ZcashChildIndex) throws -> ZcashExtendedFullViewingKey {
        return try FfiConverterTypeZcashExtendedFullViewingKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_child(self.pointer,
                                                                                       FfiConverterTypeZcashChildIndex.lower(i), $0)
            }
        )
    }

    public func deriveInternal() -> ZcashExtendedFullViewingKey {
        return try! FfiConverterTypeZcashExtendedFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_internal(self.pointer, $0)
                }
        )
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_encode(self.pointer,
                                                                                     FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashDiversifierIndexAndPaymentAddress? {
        return try! FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_find_address(self.pointer,
                                                                                           FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey {
        return try! FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_diversifiable_full_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtendedFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedFullViewingKey {
        return ZcashExtendedFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedFullViewingKey {
    return try FfiConverterTypeZcashExtendedFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedFullViewingKey_lower(_ value: ZcashExtendedFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedFullViewingKey.lower(value)
}

public protocol ZcashExtendedPrivKeyProtocol {
    func derivePrivateKey(keyIndex: ZcashKeyIndex) throws -> ZcashExtendedPrivKey

    func toBytes() -> [UInt8]
}

public class ZcashExtendedPrivKey: ZcashExtendedPrivKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashextendedprivkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public static func random() throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random($0)
        })
    }

    public static func randomWithSeedSize(seedSize: ZcashKeySeed) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random_with_seed_size(
                FfiConverterTypeZcashKeySeed.lower(seedSize), $0
            )
        })
    }

    public static func withSeed(data: [UInt8]) throws -> ZcashExtendedPrivKey {
        return try ZcashExtendedPrivKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_with_seed(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func derivePrivateKey(keyIndex: ZcashKeyIndex) throws -> ZcashExtendedPrivKey {
        return try FfiConverterTypeZcashExtendedPrivKey.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_derive_private_key(self.pointer,
                                                                                      FfiConverterTypeZcashKeyIndex.lower(keyIndex), $0)
            }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtendedPrivKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedPrivKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedPrivKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedPrivKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedPrivKey {
        return ZcashExtendedPrivKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedPrivKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedPrivKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedPrivKey {
    return try FfiConverterTypeZcashExtendedPrivKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedPrivKey_lower(_ value: ZcashExtendedPrivKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedPrivKey.lower(value)
}

public protocol ZcashExtendedSpendingKeyProtocol {
    func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress

    func deriveChild(index: ZcashChildIndex) -> ZcashExtendedSpendingKey

    func deriveInternal() -> ZcashExtendedSpendingKey

    func encode(params: ZcashConsensusParameters) -> String

    func toBytes() -> [UInt8]

    func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey
}

public class ZcashExtendedSpendingKey: ZcashExtendedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashextendedspendingkey(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashExtendedSpendingKey {
        return try ZcashExtendedSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(input), $0
            )
        })
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExtendedSpendingKey {
        return try ZcashExtendedSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func fromPath(master: ZcashExtendedSpendingKey, path: [ZcashChildIndex]) -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_path(
                FfiConverterTypeZcashExtendedSpendingKey.lower(master),
                FfiConverterSequenceTypeZcashChildIndex.lower(path), $0
            )
        })
    }

    public static func master(data: [UInt8]) -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_master(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func defaultAddress() -> ZcashDiversifierIndexAndPaymentAddress {
        return try! FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_default_address(self.pointer, $0)
                }
        )
    }

    public func deriveChild(index: ZcashChildIndex) -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_child(self.pointer,
                                                                                        FfiConverterTypeZcashChildIndex.lower(index), $0)
                }
        )
    }

    public func deriveInternal() -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_internal(self.pointer, $0)
                }
        )
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_encode(self.pointer,
                                                                                  FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toDiversifiableFullViewingKey() -> ZcashDiversifiableFullViewingKey {
        return try! FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_diversifiable_full_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtendedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtendedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtendedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtendedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtendedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtendedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtendedSpendingKey {
    return try FfiConverterTypeZcashExtendedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashExtendedSpendingKey_lower(_ value: ZcashExtendedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtendedSpendingKey.lower(value)
}

public protocol ZcashExternalIvkProtocol {
    func defaultAddress() -> ZcashTransparentAddressAndIndex

    func deriveAddress(childIndex: UInt32) throws -> ZcashTransparentAddress

    func toBytes() -> [UInt8]
}

public class ZcashExternalIvk: ZcashExternalIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashexternalivk(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExternalIvk {
        return try ZcashExternalIvk(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashexternalivk_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func defaultAddress() -> ZcashTransparentAddressAndIndex {
        return try! FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashexternalivk_default_address(self.pointer, $0)
                }
        )
    }

    public func deriveAddress(childIndex: UInt32) throws -> ZcashTransparentAddress {
        return try FfiConverterTypeZcashTransparentAddress.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashexternalivk_derive_address(self.pointer,
                                                                              FfiConverterUInt32.lower(childIndex), $0)
            }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashexternalivk_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExternalIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExternalIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExternalIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExternalIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalIvk {
        return ZcashExternalIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExternalIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExternalIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalIvk {
    return try FfiConverterTypeZcashExternalIvk.lift(pointer)
}

public func FfiConverterTypeZcashExternalIvk_lower(_ value: ZcashExternalIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExternalIvk.lower(value)
}

public protocol ZcashExternalOvkProtocol {
    func asBytes() -> [UInt8]
}

public class ZcashExternalOvk: ZcashExternalOvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashexternalovk(pointer, $0) }
    }

    public func asBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashexternalovk_as_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExternalOvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExternalOvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExternalOvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExternalOvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalOvk {
        return ZcashExternalOvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExternalOvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExternalOvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExternalOvk {
    return try FfiConverterTypeZcashExternalOvk.lift(pointer)
}

public func FfiConverterTypeZcashExternalOvk_lower(_ value: ZcashExternalOvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExternalOvk.lower(value)
}

public protocol ZcashExtractedNoteCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashExtractedNoteCommitment: ZcashExtractedNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashextractednotecommitment(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashExtractedNoteCommitment {
        return try ZcashExtractedNoteCommitment(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashextractednotecommitment_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashextractednotecommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashExtractedNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashExtractedNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashExtractedNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashExtractedNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtractedNoteCommitment {
        return ZcashExtractedNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashExtractedNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashExtractedNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashExtractedNoteCommitment {
    return try FfiConverterTypeZcashExtractedNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashExtractedNoteCommitment_lower(_ value: ZcashExtractedNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashExtractedNoteCommitment.lower(value)
}

public protocol ZcashFixedFeeRuleProtocol {
    func fixedFee() -> ZcashAmount
}

public class ZcashFixedFeeRule: ZcashFixedFeeRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashfixedfeerule(pointer, $0) }
    }

    public static func nonStandard(fixedFee: ZcashAmount) -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_non_standard(
                FfiConverterTypeZcashAmount.lower(fixedFee), $0
            )
        })
    }

    public static func standard() -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_standard($0)
        })
    }

    public func fixedFee() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashfixedfeerule_fixed_fee(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashFixedFeeRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFixedFeeRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFixedFeeRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFixedFeeRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedFeeRule {
        return ZcashFixedFeeRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFixedFeeRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFixedFeeRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedFeeRule {
    return try FfiConverterTypeZcashFixedFeeRule.lift(pointer)
}

public func FfiConverterTypeZcashFixedFeeRule_lower(_ value: ZcashFixedFeeRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFixedFeeRule.lower(value)
}

public protocol ZcashFixedSingleOutputChangeStrategyProtocol {}

public class ZcashFixedSingleOutputChangeStrategy: ZcashFixedSingleOutputChangeStrategyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(feeRule: ZcashFixedFeeRule) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashfixedsingleoutputchangestrategy_new(
                FfiConverterTypeZcashFixedFeeRule.lower(feeRule), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashfixedsingleoutputchangestrategy(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashFixedSingleOutputChangeStrategy: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFixedSingleOutputChangeStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFixedSingleOutputChangeStrategy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFixedSingleOutputChangeStrategy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedSingleOutputChangeStrategy {
        return ZcashFixedSingleOutputChangeStrategy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFixedSingleOutputChangeStrategy) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFixedSingleOutputChangeStrategy_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFixedSingleOutputChangeStrategy {
    return try FfiConverterTypeZcashFixedSingleOutputChangeStrategy.lift(pointer)
}

public func FfiConverterTypeZcashFixedSingleOutputChangeStrategy_lower(_ value: ZcashFixedSingleOutputChangeStrategy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFixedSingleOutputChangeStrategy.lower(value)
}

public protocol ZcashFsBlockDbProtocol {
    func findBlock(height: ZcashBlockHeight) throws -> ZcashBlockMeta?

    func getMaxCachedHeight() throws -> ZcashBlockHeight?

    func writeBlockMetadata(blockMeta: [ZcashBlockMeta]) throws
}

public class ZcashFsBlockDb: ZcashFsBlockDbProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashfsblockdb(pointer, $0) }
    }

    public static func forPath(fsblockdbRoot: String) throws -> ZcashFsBlockDb {
        return try ZcashFsBlockDb(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashfsblockdb_for_path(
                FfiConverterString.lower(fsblockdbRoot), $0
            )
        })
    }

    public func findBlock(height: ZcashBlockHeight) throws -> ZcashBlockMeta? {
        return try FfiConverterOptionTypeZcashBlockMeta.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashfsblockdb_find_block(self.pointer,
                                                                        FfiConverterTypeZcashBlockHeight.lower(height), $0)
            }
        )
    }

    public func getMaxCachedHeight() throws -> ZcashBlockHeight? {
        return try FfiConverterOptionTypeZcashBlockHeight.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashfsblockdb_get_max_cached_height(self.pointer, $0)
            }
        )
    }

    public func writeBlockMetadata(blockMeta: [ZcashBlockMeta]) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashfsblockdb_write_block_metadata(self.pointer,
                                                                                  FfiConverterSequenceTypeZcashBlockMeta.lower(blockMeta), $0)
            }
    }
}

public struct FfiConverterTypeZcashFsBlockDb: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFsBlockDb

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFsBlockDb {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFsBlockDb, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFsBlockDb {
        return ZcashFsBlockDb(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFsBlockDb) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFsBlockDb_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFsBlockDb {
    return try FfiConverterTypeZcashFsBlockDb.lift(pointer)
}

public func FfiConverterTypeZcashFsBlockDb_lower(_ value: ZcashFsBlockDb) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFsBlockDb.lower(value)
}

public protocol ZcashFullViewingKeyProtocol {
    func ovk() -> ZcashOutgoingViewingKey

    func toBytes() -> [UInt8]

    func vk() -> ZcashViewingKey
}

public class ZcashFullViewingKey: ZcashFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashfullviewingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashFullViewingKey {
        return try ZcashFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public static func fromExpandedSpendingKey(expsk: ZcashExpandedSpendingKey) -> ZcashFullViewingKey {
        return ZcashFullViewingKey(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_expanded_spending_key(
                FfiConverterTypeZcashExpandedSpendingKey.lower(expsk), $0
            )
        })
    }

    public func ovk() -> ZcashOutgoingViewingKey {
        return try! FfiConverterTypeZcashOutgoingViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_ovk(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func vk() -> ZcashViewingKey {
        return try! FfiConverterTypeZcashViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_vk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFullViewingKey {
        return ZcashFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashFullViewingKey {
    return try FfiConverterTypeZcashFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashFullViewingKey_lower(_ value: ZcashFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashFullViewingKey.lower(value)
}

public protocol ZcashGreedyInputSelectorProtocol {}

public class ZcashGreedyInputSelector: ZcashGreedyInputSelectorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashgreedyinputselector(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashGreedyInputSelector: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashGreedyInputSelector

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashGreedyInputSelector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashGreedyInputSelector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashGreedyInputSelector {
        return ZcashGreedyInputSelector(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashGreedyInputSelector) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashGreedyInputSelector_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashGreedyInputSelector {
    return try FfiConverterTypeZcashGreedyInputSelector.lift(pointer)
}

public func FfiConverterTypeZcashGreedyInputSelector_lower(_ value: ZcashGreedyInputSelector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashGreedyInputSelector.lower(value)
}

public protocol ZcashIncrementalWitnessProtocol {
    func append(node: ZcashSaplingNode) throws

    func path() -> ZcashSaplingMerklePath?
}

public class ZcashIncrementalWitness: ZcashIncrementalWitnessProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashincrementalwitness(pointer, $0) }
    }

    public static func fromTree(tree: ZcashCommitmentTree) -> ZcashIncrementalWitness {
        return ZcashIncrementalWitness(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashincrementalwitness_from_tree(
                FfiConverterTypeZcashCommitmentTree.lower(tree), $0
            )
        })
    }

    public func append(node: ZcashSaplingNode) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_append(self.pointer,
                                                                             FfiConverterTypeZcashSaplingNode.lower(node), $0)
            }
    }

    public func path() -> ZcashSaplingMerklePath? {
        return try! FfiConverterOptionTypeZcashSaplingMerklePath.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_path(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashIncrementalWitness: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashIncrementalWitness

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashIncrementalWitness {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashIncrementalWitness, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashIncrementalWitness {
        return ZcashIncrementalWitness(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashIncrementalWitness) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashIncrementalWitness_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashIncrementalWitness {
    return try FfiConverterTypeZcashIncrementalWitness.lift(pointer)
}

public func FfiConverterTypeZcashIncrementalWitness_lower(_ value: ZcashIncrementalWitness) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashIncrementalWitness.lower(value)
}

public protocol ZcashInternalIvkProtocol {
    func defaultAddress() -> ZcashTransparentAddressAndIndex

    func toBytes() -> [UInt8]
}

public class ZcashInternalIvk: ZcashInternalIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashinternalivk(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashInternalIvk {
        return try ZcashInternalIvk(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashinternalivk_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func defaultAddress() -> ZcashTransparentAddressAndIndex {
        return try! FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashinternalivk_default_address(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashinternalivk_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashInternalIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashInternalIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashInternalIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalIvk {
        return ZcashInternalIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashInternalIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashInternalIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalIvk {
    return try FfiConverterTypeZcashInternalIvk.lift(pointer)
}

public func FfiConverterTypeZcashInternalIvk_lower(_ value: ZcashInternalIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashInternalIvk.lower(value)
}

public protocol ZcashInternalOvkProtocol {
    func asBytes() -> [UInt8]
}

public class ZcashInternalOvk: ZcashInternalOvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashinternalovk(pointer, $0) }
    }

    public func asBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashinternalovk_as_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashInternalOvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashInternalOvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalOvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashInternalOvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalOvk {
        return ZcashInternalOvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashInternalOvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashInternalOvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashInternalOvk {
    return try FfiConverterTypeZcashInternalOvk.lift(pointer)
}

public func FfiConverterTypeZcashInternalOvk_lower(_ value: ZcashInternalOvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashInternalOvk.lower(value)
}

public protocol ZcashJubjubFrProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashJubjubFr: ZcashJubjubFrProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashjubjubfr(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashJubjubFr {
        return try ZcashJubjubFr(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashjubjubfr_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashjubjubfr_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashJubjubFr: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashJubjubFr

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashJubjubFr {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashJubjubFr, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashJubjubFr {
        return ZcashJubjubFr(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashJubjubFr) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashJubjubFr_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashJubjubFr {
    return try FfiConverterTypeZcashJubjubFr.lift(pointer)
}

public func FfiConverterTypeZcashJubjubFr_lower(_ value: ZcashJubjubFr) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashJubjubFr.lower(value)
}

public protocol ZcashKeyIndexProtocol {
    func isValid() -> Bool

    func normalizeIndex() -> UInt32

    func rawIndex() -> UInt32
}

public class ZcashKeyIndex: ZcashKeyIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashkeyindex(pointer, $0) }
    }

    public static func fromIndex(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_index(
                FfiConverterUInt32.lower(i), $0
            )
        })
    }

    public static func fromU32(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_u32(
                FfiConverterUInt32.lower(i), $0
            )
        })
    }

    public static func hardenedFromNormalizeIndex(i: UInt32) throws -> ZcashKeyIndex {
        return try ZcashKeyIndex(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_hardened_from_normalize_index(
                FfiConverterUInt32.lower(i), $0
            )
        })
    }

    public func isValid() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashkeyindex_is_valid(self.pointer, $0)
                }
        )
    }

    public func normalizeIndex() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashkeyindex_normalize_index(self.pointer, $0)
                }
        )
    }

    public func rawIndex() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashkeyindex_raw_index(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashKeyIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashKeyIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeyIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashKeyIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashKeyIndex {
        return ZcashKeyIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashKeyIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashKeyIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashKeyIndex {
    return try FfiConverterTypeZcashKeyIndex.lift(pointer)
}

public func FfiConverterTypeZcashKeyIndex_lower(_ value: ZcashKeyIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashKeyIndex.lower(value)
}

public protocol ZcashLocalTxProverProtocol {}

public class ZcashLocalTxProver: ZcashLocalTxProverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(spendPath: String, outputPath: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_new(
                FfiConverterString.lower(spendPath),
                FfiConverterString.lower(outputPath), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashlocaltxprover(pointer, $0) }
    }

    public static func fromBytes(spendParamBytes: [UInt8], outputParamBytes: [UInt8]) -> ZcashLocalTxProver {
        return ZcashLocalTxProver(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_from_bytes(
                FfiConverterSequenceUInt8.lower(spendParamBytes),
                FfiConverterSequenceUInt8.lower(outputParamBytes), $0
            )
        })
    }

    public static func withDefaultLocation() throws -> ZcashLocalTxProver {
        return try ZcashLocalTxProver(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_with_default_location($0)
        })
    }
}

public struct FfiConverterTypeZcashLocalTxProver: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashLocalTxProver

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashLocalTxProver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashLocalTxProver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashLocalTxProver {
        return ZcashLocalTxProver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashLocalTxProver) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashLocalTxProver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashLocalTxProver {
    return try FfiConverterTypeZcashLocalTxProver.lift(pointer)
}

public func FfiConverterTypeZcashLocalTxProver_lower(_ value: ZcashLocalTxProver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashLocalTxProver.lower(value)
}

public protocol ZcashMainGreedyInputSelectorProtocol {}

public class ZcashMainGreedyInputSelector: ZcashMainGreedyInputSelectorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(changeStrategy: ZcashFixedSingleOutputChangeStrategy, dustOutputPolicy: ZcashDustOutputPolicy) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashmaingreedyinputselector_new(
                FfiConverterTypeZcashFixedSingleOutputChangeStrategy.lower(changeStrategy),
                FfiConverterTypeZcashDustOutputPolicy.lower(dustOutputPolicy), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashmaingreedyinputselector(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashMainGreedyInputSelector: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashMainGreedyInputSelector

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashMainGreedyInputSelector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashMainGreedyInputSelector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMainGreedyInputSelector {
        return ZcashMainGreedyInputSelector(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashMainGreedyInputSelector) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashMainGreedyInputSelector_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMainGreedyInputSelector {
    return try FfiConverterTypeZcashMainGreedyInputSelector.lift(pointer)
}

public func FfiConverterTypeZcashMainGreedyInputSelector_lower(_ value: ZcashMainGreedyInputSelector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashMainGreedyInputSelector.lower(value)
}

public protocol ZcashMemoBytesProtocol {
    func data() -> [UInt8]
}

public class ZcashMemoBytes: ZcashMemoBytesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_new(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashmemobytes(pointer, $0) }
    }

    public static func empty() -> ZcashMemoBytes {
        return ZcashMemoBytes(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_empty($0)
        })
    }

    public func data() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashmemobytes_data(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashMemoBytes: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashMemoBytes

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashMemoBytes {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashMemoBytes, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMemoBytes {
        return ZcashMemoBytes(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashMemoBytes) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashMemoBytes_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashMemoBytes {
    return try FfiConverterTypeZcashMemoBytes.lift(pointer)
}

public func FfiConverterTypeZcashMemoBytes_lower(_ value: ZcashMemoBytes) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashMemoBytes.lower(value)
}

public protocol ZcashNonNegativeAmountProtocol {
    func value() -> UInt64
}

public class ZcashNonNegativeAmount: ZcashNonNegativeAmountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashnonnegativeamount(pointer, $0) }
    }

    public static func fromNonnegativeI64(amount: Int64) throws -> ZcashNonNegativeAmount {
        return try ZcashNonNegativeAmount(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_nonnegative_i64(
                FfiConverterInt64.lower(amount), $0
            )
        })
    }

    public static func fromU64(amount: UInt64) throws -> ZcashNonNegativeAmount {
        return try ZcashNonNegativeAmount(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_u64(
                FfiConverterUInt64.lower(amount), $0
            )
        })
    }

    public static func zero() -> ZcashNonNegativeAmount {
        return ZcashNonNegativeAmount(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_zero($0)
        })
    }

    public func value() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashnonnegativeamount_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashNonNegativeAmount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashNonNegativeAmount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashNonNegativeAmount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashNonNegativeAmount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNonNegativeAmount {
        return ZcashNonNegativeAmount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashNonNegativeAmount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashNonNegativeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNonNegativeAmount {
    return try FfiConverterTypeZcashNonNegativeAmount.lift(pointer)
}

public func FfiConverterTypeZcashNonNegativeAmount_lower(_ value: ZcashNonNegativeAmount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashNonNegativeAmount.lower(value)
}

public protocol ZcashNoteIdProtocol {}

public class ZcashNoteId: ZcashNoteIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(txid: ZcashTxId, zsp: ZcashShieldedProtocol, outputIndex: UInt16) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashnoteid_new(
                FfiConverterTypeZcashTxId.lower(txid),
                FfiConverterTypeZcashShieldedProtocol.lower(zsp),
                FfiConverterUInt16.lower(outputIndex), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashnoteid(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashNoteId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashNoteId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashNoteId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashNoteId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNoteId {
        return ZcashNoteId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashNoteId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashNoteId_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNoteId {
    return try FfiConverterTypeZcashNoteId.lift(pointer)
}

public func FfiConverterTypeZcashNoteId_lower(_ value: ZcashNoteId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashNoteId.lower(value)
}

public protocol ZcashNullifierDerivingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashNullifierDerivingKey: ZcashNullifierDerivingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashnullifierderivingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashNullifierDerivingKey {
        return try ZcashNullifierDerivingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashnullifierderivingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashnullifierderivingkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashNullifierDerivingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashNullifierDerivingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashNullifierDerivingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashNullifierDerivingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNullifierDerivingKey {
        return ZcashNullifierDerivingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashNullifierDerivingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashNullifierDerivingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashNullifierDerivingKey {
    return try FfiConverterTypeZcashNullifierDerivingKey.lift(pointer)
}

public func FfiConverterTypeZcashNullifierDerivingKey_lower(_ value: ZcashNullifierDerivingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashNullifierDerivingKey.lower(value)
}

public protocol ZcashOrchardActionProtocol {
    func cmx() -> ZcashExtractedNoteCommitment

    func cvNet() -> ZcashOrchardValueCommitment

    func encryptedNote() -> ZcashOrchardTransmittedNoteCiphertext

    func nullifier() -> ZcashOrchardNullifier
}

public class ZcashOrchardAction: ZcashOrchardActionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardaction(pointer, $0) }
    }

    public func cmx() -> ZcashExtractedNoteCommitment {
        return try! FfiConverterTypeZcashExtractedNoteCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaction_cmx(self.pointer, $0)
                }
        )
    }

    public func cvNet() -> ZcashOrchardValueCommitment {
        return try! FfiConverterTypeZcashOrchardValueCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaction_cv_net(self.pointer, $0)
                }
        )
    }

    public func encryptedNote() -> ZcashOrchardTransmittedNoteCiphertext {
        return try! FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaction_encrypted_note(self.pointer, $0)
                }
        )
    }

    public func nullifier() -> ZcashOrchardNullifier {
        return try! FfiConverterTypeZcashOrchardNullifier.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaction_nullifier(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardAction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardAction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardAction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAction {
        return ZcashOrchardAction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardAction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardAction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAction {
    return try FfiConverterTypeZcashOrchardAction.lift(pointer)
}

public func FfiConverterTypeZcashOrchardAction_lower(_ value: ZcashOrchardAction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardAction.lower(value)
}

public protocol ZcashOrchardAddressProtocol {
    func diversifier() -> ZcashOrchardDiversifier

    func toRawAddressBytes() -> [UInt8]
}

public class ZcashOrchardAddress: ZcashOrchardAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardaddress(pointer, $0) }
    }

    public static func fromRawAddressBytes(bytes: [UInt8]) throws -> ZcashOrchardAddress {
        return try ZcashOrchardAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardaddress_from_raw_address_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func diversifier() -> ZcashOrchardDiversifier {
        return try! FfiConverterTypeZcashOrchardDiversifier.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaddress_diversifier(self.pointer, $0)
                }
        )
    }

    public func toRawAddressBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardaddress_to_raw_address_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAddress {
        return ZcashOrchardAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardAddress {
    return try FfiConverterTypeZcashOrchardAddress.lift(pointer)
}

public func FfiConverterTypeZcashOrchardAddress_lower(_ value: ZcashOrchardAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardAddress.lower(value)
}

public protocol ZcashOrchardBundleProtocol {
    func actions() -> [ZcashOrchardAction]

    func anchor() -> ZcashAnchor

    func decryptOutputWithKey(actionIdx: UInt64, ivk: ZcashOrchardIncomingViewingKey) throws -> ZcashOrchardDecryptOutput

    func decryptOutputWithKeys(ivks: [ZcashOrchardIncomingViewingKey]) -> [ZcashOrchardDecryptOutputForIncomingKeys]

    func flags() -> ZcashOrchardFlags

    func recoverOutputWithOvk(actionIdx: UInt64, ovk: ZcashOrchardOutgoingViewingKey) throws -> ZcashOrchardDecryptOutput

    func recoverOutputsWithOvks(ovks: [ZcashOrchardOutgoingViewingKey]) -> [ZcashOrchardDecryptOutputForOutgoingKeys]

    func valueBalance() -> ZcashAmount

    func verifyProof(key: ZcashVerifyingKey) throws
}

public class ZcashOrchardBundle: ZcashOrchardBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardbundle(pointer, $0) }
    }

    public func actions() -> [ZcashOrchardAction] {
        return try! FfiConverterSequenceTypeZcashOrchardAction.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_actions(self.pointer, $0)
                }
        )
    }

    public func anchor() -> ZcashAnchor {
        return try! FfiConverterTypeZcashAnchor.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_anchor(self.pointer, $0)
                }
        )
    }

    public func decryptOutputWithKey(actionIdx: UInt64, ivk: ZcashOrchardIncomingViewingKey) throws -> ZcashOrchardDecryptOutput {
        return try FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_key(self.pointer,
                                                                                         FfiConverterUInt64.lower(actionIdx),
                                                                                         FfiConverterTypeZcashOrchardIncomingViewingKey.lower(ivk), $0)
            }
        )
    }

    public func decryptOutputWithKeys(ivks: [ZcashOrchardIncomingViewingKey]) -> [ZcashOrchardDecryptOutputForIncomingKeys] {
        return try! FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_keys(self.pointer,
                                                                                              FfiConverterSequenceTypeZcashOrchardIncomingViewingKey.lower(ivks), $0)
                }
        )
    }

    public func flags() -> ZcashOrchardFlags {
        return try! FfiConverterTypeZcashOrchardFlags.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_flags(self.pointer, $0)
                }
        )
    }

    public func recoverOutputWithOvk(actionIdx: UInt64, ovk: ZcashOrchardOutgoingViewingKey) throws -> ZcashOrchardDecryptOutput {
        return try FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_output_with_ovk(self.pointer,
                                                                                         FfiConverterUInt64.lower(actionIdx),
                                                                                         FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(ovk), $0)
            }
        )
    }

    public func recoverOutputsWithOvks(ovks: [ZcashOrchardOutgoingViewingKey]) -> [ZcashOrchardDecryptOutputForOutgoingKeys] {
        return try! FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_outputs_with_ovks(self.pointer,
                                                                                               FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey.lower(ovks), $0)
                }
        )
    }

    public func valueBalance() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardbundle_value_balance(self.pointer, $0)
                }
        )
    }

    public func verifyProof(key: ZcashVerifyingKey) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashorchardbundle_verify_proof(self.pointer,
                                                                              FfiConverterTypeZcashVerifyingKey.lower(key), $0)
            }
    }
}

public struct FfiConverterTypeZcashOrchardBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardBundle {
        return ZcashOrchardBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardBundle {
    return try FfiConverterTypeZcashOrchardBundle.lift(pointer)
}

public func FfiConverterTypeZcashOrchardBundle_lower(_ value: ZcashOrchardBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardBundle.lower(value)
}

public protocol ZcashOrchardDiversifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardDiversifier: ZcashOrchardDiversifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorcharddiversifier(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardDiversifier {
        return try ZcashOrchardDiversifier(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifier_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorcharddiversifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardDiversifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardDiversifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDiversifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardDiversifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifier {
        return ZcashOrchardDiversifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardDiversifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardDiversifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifier {
    return try FfiConverterTypeZcashOrchardDiversifier.lift(pointer)
}

public func FfiConverterTypeZcashOrchardDiversifier_lower(_ value: ZcashOrchardDiversifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardDiversifier.lower(value)
}

public protocol ZcashOrchardDiversifierIndexProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardDiversifierIndex: ZcashOrchardDiversifierIndexProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorcharddiversifierindex(pointer, $0) }
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashOrchardDiversifierIndex {
        return try ZcashOrchardDiversifierIndex(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_bytes(
                FfiConverterSequenceUInt8.lower(b), $0
            )
        })
    }

    public static func fromU32(i: UInt32) -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u32(
                FfiConverterUInt32.lower(i), $0
            )
        })
    }

    public static func fromU64(i: UInt64) -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u64(
                FfiConverterUInt64.lower(i), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorcharddiversifierindex_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardDiversifierIndex: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardDiversifierIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDiversifierIndex {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardDiversifierIndex, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardDiversifierIndex) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardDiversifierIndex_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardDiversifierIndex {
    return try FfiConverterTypeZcashOrchardDiversifierIndex.lift(pointer)
}

public func FfiConverterTypeZcashOrchardDiversifierIndex_lower(_ value: ZcashOrchardDiversifierIndex) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardDiversifierIndex.lower(value)
}

public protocol ZcashOrchardFlagsProtocol {
    func outputsEnabled() -> Bool

    func spendsEnabled() -> Bool

    func toByte() -> UInt8
}

public class ZcashOrchardFlags: ZcashOrchardFlagsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardflags(pointer, $0) }
    }

    public static func fromByte(v: UInt8) throws -> ZcashOrchardFlags {
        return try ZcashOrchardFlags(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_byte(
                FfiConverterUInt8.lower(v), $0
            )
        })
    }

    public static func fromParts(spendsEnabled: Bool, outputsEnabled: Bool) -> ZcashOrchardFlags {
        return ZcashOrchardFlags(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_parts(
                FfiConverterBool.lower(spendsEnabled),
                FfiConverterBool.lower(outputsEnabled), $0
            )
        })
    }

    public func outputsEnabled() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardflags_outputs_enabled(self.pointer, $0)
                }
        )
    }

    public func spendsEnabled() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardflags_spends_enabled(self.pointer, $0)
                }
        )
    }

    public func toByte() -> UInt8 {
        return try! FfiConverterUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardflags_to_byte(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardFlags: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardFlags

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardFlags {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardFlags, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFlags {
        return ZcashOrchardFlags(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardFlags) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardFlags_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFlags {
    return try FfiConverterTypeZcashOrchardFlags.lift(pointer)
}

public func FfiConverterTypeZcashOrchardFlags_lower(_ value: ZcashOrchardFlags) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardFlags.lower(value)
}

public protocol ZcashOrchardFullViewingKeyProtocol {
    func address(d: ZcashOrchardDiversifier, scope: ZcashOrchardScope) -> ZcashOrchardAddress

    func addressAt(j: ZcashOrchardDiversifierIndex, scope: ZcashOrchardScope) -> ZcashOrchardAddress

    func scopeForAddress(address: ZcashOrchardAddress) -> ZcashOrchardScope?

    func toBytes() -> [UInt8]

    func toIvk(scope: ZcashOrchardScope) -> ZcashOrchardIncomingViewingKey

    func toOvk(scope: ZcashOrchardScope) -> ZcashOrchardOutgoingViewingKey
}

public class ZcashOrchardFullViewingKey: ZcashOrchardFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardfullviewingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardFullViewingKey {
        return try ZcashOrchardFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardfullviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func address(d: ZcashOrchardDiversifier, scope: ZcashOrchardScope) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address(self.pointer,
                                                                                     FfiConverterTypeZcashOrchardDiversifier.lower(d),
                                                                                     FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func addressAt(j: ZcashOrchardDiversifierIndex, scope: ZcashOrchardScope) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address_at(self.pointer,
                                                                                        FfiConverterTypeZcashOrchardDiversifierIndex.lower(j),
                                                                                        FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func scopeForAddress(address: ZcashOrchardAddress) -> ZcashOrchardScope? {
        return try! FfiConverterOptionTypeZcashOrchardScope.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_scope_for_address(self.pointer,
                                                                                               FfiConverterTypeZcashOrchardAddress.lower(address), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toIvk(scope: ZcashOrchardScope) -> ZcashOrchardIncomingViewingKey {
        return try! FfiConverterTypeZcashOrchardIncomingViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ivk(self.pointer,
                                                                                    FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }

    public func toOvk(scope: ZcashOrchardScope) -> ZcashOrchardOutgoingViewingKey {
        return try! FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ovk(self.pointer,
                                                                                    FfiConverterTypeZcashOrchardScope.lower(scope), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFullViewingKey {
        return ZcashOrchardFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardFullViewingKey {
    return try FfiConverterTypeZcashOrchardFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardFullViewingKey_lower(_ value: ZcashOrchardFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardFullViewingKey.lower(value)
}

public protocol ZcashOrchardIncomingViewingKeyProtocol {
    func address(diversifier: ZcashOrchardDiversifier) -> ZcashOrchardAddress

    func addressAt(j: ZcashOrchardDiversifierIndex) -> ZcashOrchardAddress

    func diversifierIndex(addr: ZcashOrchardAddress) -> ZcashOrchardDiversifierIndex?

    func toBytes() -> [UInt8]
}

public class ZcashOrchardIncomingViewingKey: ZcashOrchardIncomingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardincomingviewingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardIncomingViewingKey {
        return try ZcashOrchardIncomingViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardincomingviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func address(diversifier: ZcashOrchardDiversifier) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address(self.pointer,
                                                                                         FfiConverterTypeZcashOrchardDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func addressAt(j: ZcashOrchardDiversifierIndex) -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address_at(self.pointer,
                                                                                            FfiConverterTypeZcashOrchardDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func diversifierIndex(addr: ZcashOrchardAddress) -> ZcashOrchardDiversifierIndex? {
        return try! FfiConverterOptionTypeZcashOrchardDiversifierIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_diversifier_index(self.pointer,
                                                                                                   FfiConverterTypeZcashOrchardAddress.lower(addr), $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardIncomingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardIncomingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardIncomingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardIncomingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardIncomingViewingKey {
        return ZcashOrchardIncomingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardIncomingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardIncomingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardIncomingViewingKey {
    return try FfiConverterTypeZcashOrchardIncomingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardIncomingViewingKey_lower(_ value: ZcashOrchardIncomingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardIncomingViewingKey.lower(value)
}

public protocol ZcashOrchardMerkleHashProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardMerkleHash: ZcashOrchardMerkleHashProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardmerklehash(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardMerkleHash {
        return try ZcashOrchardMerkleHash(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func fromCmx(cmx: ZcashExtractedNoteCommitment) -> ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_cmx(
                FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardmerklehash_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardMerkleHash: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardMerkleHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardMerkleHash {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardMerkleHash, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardMerkleHash) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardMerkleHash_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerkleHash {
    return try FfiConverterTypeZcashOrchardMerkleHash.lift(pointer)
}

public func FfiConverterTypeZcashOrchardMerkleHash_lower(_ value: ZcashOrchardMerkleHash) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardMerkleHash.lower(value)
}

public protocol ZcashOrchardMerklePathProtocol {
    func root(cmx: ZcashExtractedNoteCommitment) -> ZcashAnchor
}

public class ZcashOrchardMerklePath: ZcashOrchardMerklePathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardmerklepath(pointer, $0) }
    }

    public static func fromParts(position: UInt32, authPath: [ZcashOrchardMerkleHash]) throws -> ZcashOrchardMerklePath {
        return try ZcashOrchardMerklePath(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklepath_from_parts(
                FfiConverterUInt32.lower(position),
                FfiConverterSequenceTypeZcashOrchardMerkleHash.lower(authPath), $0
            )
        })
    }

    public func root(cmx: ZcashExtractedNoteCommitment) -> ZcashAnchor {
        return try! FfiConverterTypeZcashAnchor.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardmerklepath_root(self.pointer,
                                                                              FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardMerklePath: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardMerklePath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardMerklePath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardMerklePath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerklePath {
        return ZcashOrchardMerklePath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardMerklePath) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardMerklePath_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardMerklePath {
    return try FfiConverterTypeZcashOrchardMerklePath.lift(pointer)
}

public func FfiConverterTypeZcashOrchardMerklePath_lower(_ value: ZcashOrchardMerklePath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardMerklePath.lower(value)
}

public protocol ZcashOrchardNoteProtocol {
    func commitment() -> ZcashOrchardNoteCommitment

    func recipient() -> ZcashOrchardAddress

    func value() -> ZcashOrchardNoteValue
}

public class ZcashOrchardNote: ZcashOrchardNoteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardnote(pointer, $0) }
    }

    public static func fromParts(recipient: ZcashOrchardAddress, value: ZcashOrchardNoteValue, rho: ZcashOrchardNullifier, rseed: ZcashOrchardRandomSeed) throws -> ZcashOrchardNote {
        return try ZcashOrchardNote(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardnote_from_parts(
                FfiConverterTypeZcashOrchardAddress.lower(recipient),
                FfiConverterTypeZcashOrchardNoteValue.lower(value),
                FfiConverterTypeZcashOrchardNullifier.lower(rho),
                FfiConverterTypeZcashOrchardRandomSeed.lower(rseed), $0
            )
        })
    }

    public func commitment() -> ZcashOrchardNoteCommitment {
        return try! FfiConverterTypeZcashOrchardNoteCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnote_commitment(self.pointer, $0)
                }
        )
    }

    public func recipient() -> ZcashOrchardAddress {
        return try! FfiConverterTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnote_recipient(self.pointer, $0)
                }
        )
    }

    public func value() -> ZcashOrchardNoteValue {
        return try! FfiConverterTypeZcashOrchardNoteValue.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnote_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNote: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNote

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNote {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNote, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNote {
        return ZcashOrchardNote(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNote) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNote_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNote {
    return try FfiConverterTypeZcashOrchardNote.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNote_lower(_ value: ZcashOrchardNote) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNote.lower(value)
}

public protocol ZcashOrchardNoteCommitmentProtocol {
    func toExtractedNoteCommitment() -> ZcashExtractedNoteCommitment
}

public class ZcashOrchardNoteCommitment: ZcashOrchardNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardnotecommitment(pointer, $0) }
    }

    public func toExtractedNoteCommitment() -> ZcashExtractedNoteCommitment {
        return try! FfiConverterTypeZcashExtractedNoteCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnotecommitment_to_extracted_note_commitment(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteCommitment {
        return ZcashOrchardNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteCommitment {
    return try FfiConverterTypeZcashOrchardNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNoteCommitment_lower(_ value: ZcashOrchardNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNoteCommitment.lower(value)
}

public protocol ZcashOrchardNoteValueProtocol {
    func value() -> UInt64
}

public class ZcashOrchardNoteValue: ZcashOrchardNoteValueProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardnotevalue(pointer, $0) }
    }

    public static func fromRaw(value: UInt64) -> ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardnotevalue_from_raw(
                FfiConverterUInt64.lower(value), $0
            )
        })
    }

    public func value() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnotevalue_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNoteValue: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNoteValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNoteValue {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNoteValue, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNoteValue) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNoteValue_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNoteValue {
    return try FfiConverterTypeZcashOrchardNoteValue.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNoteValue_lower(_ value: ZcashOrchardNoteValue) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNoteValue.lower(value)
}

public protocol ZcashOrchardNullifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardNullifier: ZcashOrchardNullifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardnullifier(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardNullifier {
        return try ZcashOrchardNullifier(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardnullifier_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardnullifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardNullifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardNullifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardNullifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardNullifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNullifier {
        return ZcashOrchardNullifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardNullifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardNullifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardNullifier {
    return try FfiConverterTypeZcashOrchardNullifier.lift(pointer)
}

public func FfiConverterTypeZcashOrchardNullifier_lower(_ value: ZcashOrchardNullifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardNullifier.lower(value)
}

public protocol ZcashOrchardOutgoingViewingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardOutgoingViewingKey: ZcashOrchardOutgoingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardoutgoingviewingkey(pointer, $0) }
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashOrchardOutgoingViewingKey {
        return try ZcashOrchardOutgoingViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardoutgoingviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardoutgoingviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardOutgoingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardOutgoingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardOutgoingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardOutgoingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardOutgoingViewingKey {
        return ZcashOrchardOutgoingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardOutgoingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardOutgoingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardOutgoingViewingKey {
    return try FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardOutgoingViewingKey_lower(_ value: ZcashOrchardOutgoingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(value)
}

public protocol ZcashOrchardRandomSeedProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardRandomSeed: ZcashOrchardRandomSeedProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardrandomseed(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8], rho: ZcashOrchardNullifier) throws -> ZcashOrchardRandomSeed {
        return try ZcashOrchardRandomSeed(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardrandomseed_from_bytes(
                FfiConverterSequenceUInt8.lower(data),
                FfiConverterTypeZcashOrchardNullifier.lower(rho), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardrandomseed_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardRandomSeed: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardRandomSeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardRandomSeed {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardRandomSeed, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardRandomSeed {
        return ZcashOrchardRandomSeed(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardRandomSeed) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardRandomSeed_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardRandomSeed {
    return try FfiConverterTypeZcashOrchardRandomSeed.lift(pointer)
}

public func FfiConverterTypeZcashOrchardRandomSeed_lower(_ value: ZcashOrchardRandomSeed) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardRandomSeed.lower(value)
}

public protocol ZcashOrchardSpendingKeyProtocol {
    func toBytes() -> [UInt8]

    func toFvk() -> ZcashOrchardFullViewingKey
}

public class ZcashOrchardSpendingKey: ZcashOrchardSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardspendingkey(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashOrchardSpendingKey {
        return try ZcashOrchardSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func fromZip32Seed(seed: [UInt8], coinType: UInt32, account: UInt32) throws -> ZcashOrchardSpendingKey {
        return try ZcashOrchardSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_zip32_seed(
                FfiConverterSequenceUInt8.lower(seed),
                FfiConverterUInt32.lower(coinType),
                FfiConverterUInt32.lower(account), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_bytes(self.pointer, $0)
                }
        )
    }

    public func toFvk() -> ZcashOrchardFullViewingKey {
        return try! FfiConverterTypeZcashOrchardFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_fvk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardSpendingKey {
        return ZcashOrchardSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardSpendingKey {
    return try FfiConverterTypeZcashOrchardSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashOrchardSpendingKey_lower(_ value: ZcashOrchardSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardSpendingKey.lower(value)
}

public protocol ZcashOrchardTransactionBuilderProtocol {
    func addRecipient(ovk: ZcashOrchardOutgoingViewingKey?, recipient: ZcashOrchardAddress, value: ZcashOrchardNoteValue, memo: [UInt8]?) throws

    func addSpend(fvk: ZcashOrchardFullViewingKey, note: ZcashOrchardNote, merklePath: ZcashOrchardMerklePath)

    func build(keys: [ZcashOrchardSpendingKey], sighash: [UInt8]) throws -> ZcashTransaction
}

public class ZcashOrchardTransactionBuilder: ZcashOrchardTransactionBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(parameters: ZcashConsensusParameters, targetHeight: ZcashBlockHeight, expiryHeight: ZcashBlockHeight, anchor: ZcashAnchor, flags: ZcashOrchardFlags) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashorchardtransactionbuilder_new(
                FfiConverterTypeZcashConsensusParameters.lower(parameters),
                FfiConverterTypeZcashBlockHeight.lower(targetHeight),
                FfiConverterTypeZcashBlockHeight.lower(expiryHeight),
                FfiConverterTypeZcashAnchor.lower(anchor),
                FfiConverterTypeZcashOrchardFlags.lower(flags), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardtransactionbuilder(pointer, $0) }
    }

    public func addRecipient(ovk: ZcashOrchardOutgoingViewingKey?, recipient: ZcashOrchardAddress, value: ZcashOrchardNoteValue, memo: [UInt8]?) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_recipient(self.pointer,
                                                                                           FfiConverterOptionTypeZcashOrchardOutgoingViewingKey.lower(ovk),
                                                                                           FfiConverterTypeZcashOrchardAddress.lower(recipient),
                                                                                           FfiConverterTypeZcashOrchardNoteValue.lower(value),
                                                                                           FfiConverterOptionSequenceUInt8.lower(memo), $0)
            }
    }

    public func addSpend(fvk: ZcashOrchardFullViewingKey, note: ZcashOrchardNote, merklePath: ZcashOrchardMerklePath) {
        try!
            rustCall {
                uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_spend(self.pointer,
                                                                                       FfiConverterTypeZcashOrchardFullViewingKey.lower(fvk),
                                                                                       FfiConverterTypeZcashOrchardNote.lower(note),
                                                                                       FfiConverterTypeZcashOrchardMerklePath.lower(merklePath), $0)
            }
    }

    public func build(keys: [ZcashOrchardSpendingKey], sighash: [UInt8]) throws -> ZcashTransaction {
        return try FfiConverterTypeZcashTransaction.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_build(self.pointer,
                                                                                   FfiConverterSequenceTypeZcashOrchardSpendingKey.lower(keys),
                                                                                   FfiConverterSequenceUInt8.lower(sighash), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashOrchardTransactionBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardTransactionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardTransactionBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardTransactionBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardTransactionBuilder {
        return ZcashOrchardTransactionBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardTransactionBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardTransactionBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardTransactionBuilder {
    return try FfiConverterTypeZcashOrchardTransactionBuilder.lift(pointer)
}

public func FfiConverterTypeZcashOrchardTransactionBuilder_lower(_ value: ZcashOrchardTransactionBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardTransactionBuilder.lower(value)
}

public protocol ZcashOrchardValueCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOrchardValueCommitment: ZcashOrchardValueCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashorchardvaluecommitment(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashorchardvaluecommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOrchardValueCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOrchardValueCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardValueCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOrchardValueCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardValueCommitment {
        return ZcashOrchardValueCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOrchardValueCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOrchardValueCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOrchardValueCommitment {
    return try FfiConverterTypeZcashOrchardValueCommitment.lift(pointer)
}

public func FfiConverterTypeZcashOrchardValueCommitment_lower(_ value: ZcashOrchardValueCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOrchardValueCommitment.lower(value)
}

public protocol ZcashOutPointProtocol {}

public class ZcashOutPoint: ZcashOutPointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(hash: [UInt8], n: UInt32) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashoutpoint_new(
                FfiConverterSequenceUInt8.lower(hash),
                FfiConverterUInt32.lower(n), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashoutpoint(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashOutPoint: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOutPoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutPoint {
        return ZcashOutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOutPoint) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutPoint {
    return try FfiConverterTypeZcashOutPoint.lift(pointer)
}

public func FfiConverterTypeZcashOutPoint_lower(_ value: ZcashOutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOutPoint.lower(value)
}

public protocol ZcashOutgoingViewingKeyProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashOutgoingViewingKey: ZcashOutgoingViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashoutgoingviewingkey(pointer, $0) }
    }

    public static func fromBytes(b: [UInt8]) throws -> ZcashOutgoingViewingKey {
        return try ZcashOutgoingViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashoutgoingviewingkey_from_bytes(
                FfiConverterSequenceUInt8.lower(b), $0
            )
        })
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashoutgoingviewingkey_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashOutgoingViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashOutgoingViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOutgoingViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashOutgoingViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutgoingViewingKey {
        return ZcashOutgoingViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashOutgoingViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashOutgoingViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashOutgoingViewingKey {
    return try FfiConverterTypeZcashOutgoingViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashOutgoingViewingKey_lower(_ value: ZcashOutgoingViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashOutgoingViewingKey.lower(value)
}

public protocol ZcashPaymentAddressProtocol {
    func createNote(value: UInt64, rseed: ZcashRseed) throws -> ZcashSaplingNote

    func diversifier() -> ZcashDiversifier

    func encode(params: ZcashConsensusParameters) -> String

    func pkD() -> ZcashSaplingDiversifiedTransmissionKey

    func toBytes() -> [UInt8]
}

public class ZcashPaymentAddress: ZcashPaymentAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashpaymentaddress(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashPaymentAddress {
        return try ZcashPaymentAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(input), $0
            )
        })
    }

    public static func fromBytes(bytes: [UInt8]) throws -> ZcashPaymentAddress {
        return try ZcashPaymentAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_from_bytes(
                FfiConverterSequenceUInt8.lower(bytes), $0
            )
        })
    }

    public func createNote(value: UInt64, rseed: ZcashRseed) throws -> ZcashSaplingNote {
        return try FfiConverterTypeZcashSaplingNote.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_create_note(self.pointer,
                                                                              FfiConverterUInt64.lower(value),
                                                                              FfiConverterTypeZcashRseed.lower(rseed), $0)
            }
        )
    }

    public func diversifier() -> ZcashDiversifier {
        return try! FfiConverterTypeZcashDiversifier.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_diversifier(self.pointer, $0)
                }
        )
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_encode(self.pointer,
                                                                             FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func pkD() -> ZcashSaplingDiversifiedTransmissionKey {
        return try! FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_pk_d(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashPaymentAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashPaymentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPaymentAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashPaymentAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashPaymentAddress {
        return ZcashPaymentAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashPaymentAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashPaymentAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashPaymentAddress {
    return try FfiConverterTypeZcashPaymentAddress.lift(pointer)
}

public func FfiConverterTypeZcashPaymentAddress_lower(_ value: ZcashPaymentAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashPaymentAddress.lower(value)
}

public protocol ZcashProofGenerationKeyProtocol {
    func toViewingKey() -> ZcashViewingKey
}

public class ZcashProofGenerationKey: ZcashProofGenerationKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashproofgenerationkey(pointer, $0) }
    }

    public func toViewingKey() -> ZcashViewingKey {
        return try! FfiConverterTypeZcashViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashproofgenerationkey_to_viewing_key(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashProofGenerationKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashProofGenerationKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashProofGenerationKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashProofGenerationKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProofGenerationKey {
        return ZcashProofGenerationKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashProofGenerationKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashProofGenerationKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProofGenerationKey {
    return try FfiConverterTypeZcashProofGenerationKey.lift(pointer)
}

public func FfiConverterTypeZcashProofGenerationKey_lower(_ value: ZcashProofGenerationKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashProofGenerationKey.lower(value)
}

public protocol ZcashProvingKeyProtocol {}

public class ZcashProvingKey: ZcashProvingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashprovingkey_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashprovingkey(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashProvingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashProvingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashProvingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashProvingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProvingKey {
        return ZcashProvingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashProvingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashProvingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashProvingKey {
    return try FfiConverterTypeZcashProvingKey.lift(pointer)
}

public func FfiConverterTypeZcashProvingKey_lower(_ value: ZcashProvingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashProvingKey.lower(value)
}

public protocol ZcashRatioProtocol {
    func denominator() -> UInt64

    func numerator() -> UInt64
}

public class ZcashRatio: ZcashRatioProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(numerator: UInt64, denominator: UInt64) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashratio_new(
                FfiConverterUInt64.lower(numerator),
                FfiConverterUInt64.lower(denominator), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashratio(pointer, $0) }
    }

    public func denominator() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashratio_denominator(self.pointer, $0)
                }
        )
    }

    public func numerator() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashratio_numerator(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashRatio: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashRatio

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashRatio {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashRatio, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRatio {
        return ZcashRatio(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashRatio) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashRatio_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRatio {
    return try FfiConverterTypeZcashRatio.lift(pointer)
}

public func FfiConverterTypeZcashRatio_lower(_ value: ZcashRatio) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashRatio.lower(value)
}

public protocol ZcashRecipientAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String
}

public class ZcashRecipientAddress: ZcashRecipientAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashrecipientaddress(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, address: String) throws -> ZcashRecipientAddress {
        return try ZcashRecipientAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(address), $0
            )
        })
    }

    public static func shielded(addr: ZcashPaymentAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_shielded(
                FfiConverterTypeZcashPaymentAddress.lower(addr), $0
            )
        })
    }

    public static func transparent(addr: ZcashTransparentAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_transparent(
                FfiConverterTypeZcashTransparentAddress.lower(addr), $0
            )
        })
    }

    public static func unified(addr: ZcashUnifiedAddress) -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_unified(
                FfiConverterTypeZcashUnifiedAddress.lower(addr), $0
            )
        })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashrecipientaddress_encode(self.pointer,
                                                                               FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashRecipientAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashRecipientAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashRecipientAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashRecipientAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRecipientAddress {
        return ZcashRecipientAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashRecipientAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashRecipientAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashRecipientAddress {
    return try FfiConverterTypeZcashRecipientAddress.lift(pointer)
}

public func FfiConverterTypeZcashRecipientAddress_lower(_ value: ZcashRecipientAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashRecipientAddress.lower(value)
}

public protocol ZcashSaplingBundleProtocol {
    func shieldedOutputs() -> [ZcashSaplingOutputDescription]

    func shieldedSpends() -> [ZcashSaplingSpendDescription]

    func valueBalance() -> ZcashAmount
}

public class ZcashSaplingBundle: ZcashSaplingBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingbundle(pointer, $0) }
    }

    public func shieldedOutputs() -> [ZcashSaplingOutputDescription] {
        return try! FfiConverterSequenceTypeZcashSaplingOutputDescription.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_outputs(self.pointer, $0)
                }
        )
    }

    public func shieldedSpends() -> [ZcashSaplingSpendDescription] {
        return try! FfiConverterSequenceTypeZcashSaplingSpendDescription.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_spends(self.pointer, $0)
                }
        )
    }

    public func valueBalance() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_value_balance(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingBundle {
        return ZcashSaplingBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingBundle {
    return try FfiConverterTypeZcashSaplingBundle.lift(pointer)
}

public func FfiConverterTypeZcashSaplingBundle_lower(_ value: ZcashSaplingBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingBundle.lower(value)
}

public protocol ZcashSaplingDiversifiedTransmissionKeyProtocol {}

public class ZcashSaplingDiversifiedTransmissionKey: ZcashSaplingDiversifiedTransmissionKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingdiversifiedtransmissionkey(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashSaplingDiversifiedTransmissionKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingDiversifiedTransmissionKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingDiversifiedTransmissionKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingDiversifiedTransmissionKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingDiversifiedTransmissionKey {
        return ZcashSaplingDiversifiedTransmissionKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingDiversifiedTransmissionKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingDiversifiedTransmissionKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingDiversifiedTransmissionKey {
    return try FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(pointer)
}

public func FfiConverterTypeZcashSaplingDiversifiedTransmissionKey_lower(_ value: ZcashSaplingDiversifiedTransmissionKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lower(value)
}

public protocol ZcashSaplingExtractedNoteCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingExtractedNoteCommitment: ZcashSaplingExtractedNoteCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(data: [UInt8]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashsaplingextractednotecommitment_new(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingextractednotecommitment(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingextractednotecommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingExtractedNoteCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingExtractedNoteCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingExtractedNoteCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingExtractedNoteCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingExtractedNoteCommitment {
        return ZcashSaplingExtractedNoteCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingExtractedNoteCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingExtractedNoteCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingExtractedNoteCommitment {
    return try FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(pointer)
}

public func FfiConverterTypeZcashSaplingExtractedNoteCommitment_lower(_ value: ZcashSaplingExtractedNoteCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(value)
}

public protocol ZcashSaplingIvkProtocol {
    func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?

    func toRepr() -> [UInt8]
}

public class ZcashSaplingIvk: ZcashSaplingIvkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingivk(pointer, $0) }
    }

    public func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_payment_address(self.pointer,
                                                                                     FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }

    public func toRepr() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_repr(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingIvk: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingIvk

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingIvk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingIvk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingIvk {
        return ZcashSaplingIvk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingIvk) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingIvk_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingIvk {
    return try FfiConverterTypeZcashSaplingIvk.lift(pointer)
}

public func FfiConverterTypeZcashSaplingIvk_lower(_ value: ZcashSaplingIvk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingIvk.lower(value)
}

public protocol ZcashSaplingMerklePathProtocol {
    func authPath() -> [ZcashAuthPath]

    func position() -> UInt64
}

public class ZcashSaplingMerklePath: ZcashSaplingMerklePathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingmerklepath(pointer, $0) }
    }

    public func authPath() -> [ZcashAuthPath] {
        return try! FfiConverterSequenceTypeZcashAuthPath.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_auth_path(self.pointer, $0)
                }
        )
    }

    public func position() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_position(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingMerklePath: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingMerklePath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingMerklePath {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingMerklePath, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMerklePath {
        return ZcashSaplingMerklePath(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingMerklePath) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingMerklePath_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMerklePath {
    return try FfiConverterTypeZcashSaplingMerklePath.lift(pointer)
}

public func FfiConverterTypeZcashSaplingMerklePath_lower(_ value: ZcashSaplingMerklePath) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingMerklePath.lower(value)
}

public protocol ZcashSaplingMetadataProtocol {
    func outputIndex(n: UInt64) -> UInt64?

    func spendIndex(n: UInt64) -> UInt64?
}

public class ZcashSaplingMetadata: ZcashSaplingMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashsaplingmetadata_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingmetadata(pointer, $0) }
    }

    public func outputIndex(n: UInt64) -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_output_index(self.pointer,
                                                                                    FfiConverterUInt64.lower(n), $0)
                }
        )
    }

    public func spendIndex(n: UInt64) -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_spend_index(self.pointer,
                                                                                   FfiConverterUInt64.lower(n), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMetadata {
        return ZcashSaplingMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingMetadata) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingMetadata {
    return try FfiConverterTypeZcashSaplingMetadata.lift(pointer)
}

public func FfiConverterTypeZcashSaplingMetadata_lower(_ value: ZcashSaplingMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingMetadata.lower(value)
}

public protocol ZcashSaplingNodeProtocol {}

public class ZcashSaplingNode: ZcashSaplingNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingnode(pointer, $0) }
    }

    public static func fromCmu(cmu: ZcashSaplingExtractedNoteCommitment) -> ZcashSaplingNode {
        return ZcashSaplingNode(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashsaplingnode_from_cmu(
                FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(cmu), $0
            )
        })
    }
}

public struct FfiConverterTypeZcashSaplingNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNode {
        return ZcashSaplingNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNode {
    return try FfiConverterTypeZcashSaplingNode.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNode_lower(_ value: ZcashSaplingNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNode.lower(value)
}

public protocol ZcashSaplingNoteProtocol {
    func cmu() -> ZcashSaplingExtractedNoteCommitment

    func value() -> ZcashSaplingNoteValue
}

public class ZcashSaplingNote: ZcashSaplingNoteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingnote(pointer, $0) }
    }

    public static func fromParts(recipient: ZcashPaymentAddress, value: ZcashSaplingNoteValue, rseed: ZcashRseed) throws -> ZcashSaplingNote {
        return try ZcashSaplingNote(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashsaplingnote_from_parts(
                FfiConverterTypeZcashPaymentAddress.lower(recipient),
                FfiConverterTypeZcashSaplingNoteValue.lower(value),
                FfiConverterTypeZcashRseed.lower(rseed), $0
            )
        })
    }

    public func cmu() -> ZcashSaplingExtractedNoteCommitment {
        return try! FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingnote_cmu(self.pointer, $0)
                }
        )
    }

    public func value() -> ZcashSaplingNoteValue {
        return try! FfiConverterTypeZcashSaplingNoteValue.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingnote_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNote: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNote

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNote {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNote, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNote {
        return ZcashSaplingNote(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNote) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNote_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNote {
    return try FfiConverterTypeZcashSaplingNote.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNote_lower(_ value: ZcashSaplingNote) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNote.lower(value)
}

public protocol ZcashSaplingNoteValueProtocol {
    func inner() -> UInt64
}

public class ZcashSaplingNoteValue: ZcashSaplingNoteValueProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingnotevalue(pointer, $0) }
    }

    public static func fromRaw(data: UInt64) -> ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashsaplingnotevalue_from_raw(
                FfiConverterUInt64.lower(data), $0
            )
        })
    }

    public func inner() -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingnotevalue_inner(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNoteValue: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNoteValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNoteValue {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNoteValue, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNoteValue) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNoteValue_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNoteValue {
    return try FfiConverterTypeZcashSaplingNoteValue.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNoteValue_lower(_ value: ZcashSaplingNoteValue) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNoteValue.lower(value)
}

public protocol ZcashSaplingNullifierProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingNullifier: ZcashSaplingNullifierProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingnullifier(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingnullifier_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingNullifier: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingNullifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingNullifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingNullifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNullifier {
        return ZcashSaplingNullifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingNullifier) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingNullifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingNullifier {
    return try FfiConverterTypeZcashSaplingNullifier.lift(pointer)
}

public func FfiConverterTypeZcashSaplingNullifier_lower(_ value: ZcashSaplingNullifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingNullifier.lower(value)
}

public protocol ZcashSaplingOutputDescriptionProtocol {
    func cmu() -> ZcashSaplingExtractedNoteCommitment

    func cv() -> ZcashSaplingValueCommitment
}

public class ZcashSaplingOutputDescription: ZcashSaplingOutputDescriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingoutputdescription(pointer, $0) }
    }

    public func cmu() -> ZcashSaplingExtractedNoteCommitment {
        return try! FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cmu(self.pointer, $0)
                }
        )
    }

    public func cv() -> ZcashSaplingValueCommitment {
        return try! FfiConverterTypeZcashSaplingValueCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cv(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingOutputDescription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingOutputDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingOutputDescription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingOutputDescription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingOutputDescription {
        return ZcashSaplingOutputDescription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingOutputDescription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingOutputDescription_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingOutputDescription {
    return try FfiConverterTypeZcashSaplingOutputDescription.lift(pointer)
}

public func FfiConverterTypeZcashSaplingOutputDescription_lower(_ value: ZcashSaplingOutputDescription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingOutputDescription.lower(value)
}

public protocol ZcashSaplingPublicKeyProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashSaplingPublicKey: ZcashSaplingPublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingpublickey(pointer, $0) }
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashsaplingpublickey_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashSaplingPublicKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingPublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingPublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingPublicKey {
        return ZcashSaplingPublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingPublicKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingPublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingPublicKey {
    return try FfiConverterTypeZcashSaplingPublicKey.lift(pointer)
}

public func FfiConverterTypeZcashSaplingPublicKey_lower(_ value: ZcashSaplingPublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingPublicKey.lower(value)
}

public protocol ZcashSaplingSpendDescriptionProtocol {
    func anchor() -> [UInt8]

    func cv() -> ZcashSaplingValueCommitment

    func nullifier() -> ZcashSaplingNullifier

    func rk() -> ZcashSaplingPublicKey
}

public class ZcashSaplingSpendDescription: ZcashSaplingSpendDescriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingspenddescription(pointer, $0) }
    }

    public func anchor() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_anchor(self.pointer, $0)
                }
        )
    }

    public func cv() -> ZcashSaplingValueCommitment {
        return try! FfiConverterTypeZcashSaplingValueCommitment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_cv(self.pointer, $0)
                }
        )
    }

    public func nullifier() -> ZcashSaplingNullifier {
        return try! FfiConverterTypeZcashSaplingNullifier.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_nullifier(self.pointer, $0)
                }
        )
    }

    public func rk() -> ZcashSaplingPublicKey {
        return try! FfiConverterTypeZcashSaplingPublicKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_rk(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingSpendDescription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingSpendDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingSpendDescription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingSpendDescription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingSpendDescription {
        return ZcashSaplingSpendDescription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingSpendDescription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingSpendDescription_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingSpendDescription {
    return try FfiConverterTypeZcashSaplingSpendDescription.lift(pointer)
}

public func FfiConverterTypeZcashSaplingSpendDescription_lower(_ value: ZcashSaplingSpendDescription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingSpendDescription.lower(value)
}

public protocol ZcashSaplingValueCommitmentProtocol {
    func toBytes() -> [UInt8]
}

public class ZcashSaplingValueCommitment: ZcashSaplingValueCommitmentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashsaplingvaluecommitment(pointer, $0) }
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashsaplingvaluecommitment_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashSaplingValueCommitment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashSaplingValueCommitment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashSaplingValueCommitment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashSaplingValueCommitment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingValueCommitment {
        return ZcashSaplingValueCommitment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashSaplingValueCommitment) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashSaplingValueCommitment_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashSaplingValueCommitment {
    return try FfiConverterTypeZcashSaplingValueCommitment.lift(pointer)
}

public func FfiConverterTypeZcashSaplingValueCommitment_lower(_ value: ZcashSaplingValueCommitment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashSaplingValueCommitment.lower(value)
}

public protocol ZcashScanRangeProtocol {
    func blockRange() -> [ZcashBlockHeight]

    func isEmpty() -> Bool

    func len() -> UInt32

    func priority() -> ZcashScanPriority
}

public class ZcashScanRange: ZcashScanRangeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashscanrange(pointer, $0) }
    }

    public static func fromParts(startBlock: ZcashBlockHeight, endBlock: ZcashBlockHeight, priority: ZcashScanPriority) -> ZcashScanRange {
        return ZcashScanRange(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashscanrange_from_parts(
                FfiConverterTypeZcashBlockHeight.lower(startBlock),
                FfiConverterTypeZcashBlockHeight.lower(endBlock),
                FfiConverterTypeZcashScanPriority.lower(priority), $0
            )
        })
    }

    public func blockRange() -> [ZcashBlockHeight] {
        return try! FfiConverterSequenceTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashscanrange_block_range(self.pointer, $0)
                }
        )
    }

    public func isEmpty() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashscanrange_is_empty(self.pointer, $0)
                }
        )
    }

    public func len() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashscanrange_len(self.pointer, $0)
                }
        )
    }

    public func priority() -> ZcashScanPriority {
        return try! FfiConverterTypeZcashScanPriority.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashscanrange_priority(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashScanRange: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashScanRange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScanRange {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashScanRange, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScanRange {
        return ZcashScanRange(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashScanRange) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashScanRange_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScanRange {
    return try FfiConverterTypeZcashScanRange.lift(pointer)
}

public func FfiConverterTypeZcashScanRange_lower(_ value: ZcashScanRange) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashScanRange.lower(value)
}

public protocol ZcashScriptProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashScript: ZcashScriptProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashscript(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashScript {
        return try ZcashScript(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashscript_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashscript_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashScript: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashScript

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScript {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashScript, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScript {
        return ZcashScript(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashScript) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashScript_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashScript {
    return try FfiConverterTypeZcashScript.lift(pointer)
}

public func FfiConverterTypeZcashScript_lower(_ value: ZcashScript) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashScript.lower(value)
}

public protocol ZcashTestGreedyInputSelectorProtocol {}

public class ZcashTestGreedyInputSelector: ZcashTestGreedyInputSelectorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(changeStrategy: ZcashFixedSingleOutputChangeStrategy, dustOutputPolicy: ZcashDustOutputPolicy) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashtestgreedyinputselector_new(
                FfiConverterTypeZcashFixedSingleOutputChangeStrategy.lower(changeStrategy),
                FfiConverterTypeZcashDustOutputPolicy.lower(dustOutputPolicy), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtestgreedyinputselector(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashTestGreedyInputSelector: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTestGreedyInputSelector

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTestGreedyInputSelector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTestGreedyInputSelector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTestGreedyInputSelector {
        return ZcashTestGreedyInputSelector(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTestGreedyInputSelector) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTestGreedyInputSelector_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTestGreedyInputSelector {
    return try FfiConverterTypeZcashTestGreedyInputSelector.lift(pointer)
}

public func FfiConverterTypeZcashTestGreedyInputSelector_lower(_ value: ZcashTestGreedyInputSelector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTestGreedyInputSelector.lower(value)
}

public protocol ZcashTransactionProtocol {
    func consensusBranchId() -> ZcashBranchId

    func expiryHeight() -> ZcashBlockHeight

    func lockTime() -> UInt32

    func orchardBundle() -> ZcashOrchardBundle?

    func saplingBundle() -> ZcashSaplingBundle?

    func toBytes() throws -> [UInt8]

    func transparentBundle() -> ZcashTransparentBundle?

    func txid() -> ZcashTxId

    func version() -> ZcashTxVersion
}

public class ZcashTransaction: ZcashTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtransaction(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8], consensusBranchId: ZcashBranchId) throws -> ZcashTransaction {
        return try ZcashTransaction(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransaction_from_bytes(
                FfiConverterSequenceUInt8.lower(data),
                FfiConverterTypeZcashBranchId.lower(consensusBranchId), $0
            )
        })
    }

    public func consensusBranchId() -> ZcashBranchId {
        return try! FfiConverterTypeZcashBranchId.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_consensus_branch_id(self.pointer, $0)
                }
        )
    }

    public func expiryHeight() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_expiry_height(self.pointer, $0)
                }
        )
    }

    public func lockTime() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_lock_time(self.pointer, $0)
                }
        )
    }

    public func orchardBundle() -> ZcashOrchardBundle? {
        return try! FfiConverterOptionTypeZcashOrchardBundle.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_orchard_bundle(self.pointer, $0)
                }
        )
    }

    public func saplingBundle() -> ZcashSaplingBundle? {
        return try! FfiConverterOptionTypeZcashSaplingBundle.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_sapling_bundle(self.pointer, $0)
                }
        )
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtransaction_to_bytes(self.pointer, $0)
            }
        )
    }

    public func transparentBundle() -> ZcashTransparentBundle? {
        return try! FfiConverterOptionTypeZcashTransparentBundle.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_transparent_bundle(self.pointer, $0)
                }
        )
    }

    public func txid() -> ZcashTxId {
        return try! FfiConverterTypeZcashTxId.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_txid(self.pointer, $0)
                }
        )
    }

    public func version() -> ZcashTxVersion {
        return try! FfiConverterTypeZcashTxVersion.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransaction_version(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransaction {
        return ZcashTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransaction {
    return try FfiConverterTypeZcashTransaction.lift(pointer)
}

public func FfiConverterTypeZcashTransaction_lower(_ value: ZcashTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransaction.lower(value)
}

public protocol ZcashTransactionBuilderProtocol {
    func addSaplingOutput(ovk: ZcashOutgoingViewingKey?, to: ZcashPaymentAddress, value: ZcashAmount, memo: ZcashMemoBytes)

    func addSaplingSpend(extsk: ZcashExtendedSpendingKey, diversifier: ZcashDiversifier, note: ZcashSaplingNote, merklePath: ZcashSaplingMerklePath)

    func addTransparentInput(sk: SecpSecretKey, utxo: ZcashOutPoint, coin: ZcashTxOut)

    func addTransparentOutput(to: ZcashTransparentAddress, value: ZcashAmount)

    func build(prover: ZcashLocalTxProver, feeRule: ZcashFeeRules) throws -> ZcashTransactionAndSaplingMetadata
}

public class ZcashTransactionBuilder: ZcashTransactionBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(parameters: ZcashConsensusParameters, blockHeight: ZcashBlockHeight) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashtransactionbuilder_new(
                FfiConverterTypeZcashConsensusParameters.lower(parameters),
                FfiConverterTypeZcashBlockHeight.lower(blockHeight), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtransactionbuilder(pointer, $0) }
    }

    public func addSaplingOutput(ovk: ZcashOutgoingViewingKey?, to: ZcashPaymentAddress, value: ZcashAmount, memo: ZcashMemoBytes) {
        try!
            rustCall {
                uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_output(self.pointer,
                                                                                         FfiConverterOptionTypeZcashOutgoingViewingKey.lower(ovk),
                                                                                         FfiConverterTypeZcashPaymentAddress.lower(to),
                                                                                         FfiConverterTypeZcashAmount.lower(value),
                                                                                         FfiConverterTypeZcashMemoBytes.lower(memo), $0)
            }
    }

    public func addSaplingSpend(extsk: ZcashExtendedSpendingKey, diversifier: ZcashDiversifier, note: ZcashSaplingNote, merklePath: ZcashSaplingMerklePath) {
        try!
            rustCall {
                uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_spend(self.pointer,
                                                                                        FfiConverterTypeZcashExtendedSpendingKey.lower(extsk),
                                                                                        FfiConverterTypeZcashDiversifier.lower(diversifier),
                                                                                        FfiConverterTypeZcashSaplingNote.lower(note),
                                                                                        FfiConverterTypeZcashSaplingMerklePath.lower(merklePath), $0)
            }
    }

    public func addTransparentInput(sk: SecpSecretKey, utxo: ZcashOutPoint, coin: ZcashTxOut) {
        try!
            rustCall {
                uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_input(self.pointer,
                                                                                            FfiConverterTypeSecpSecretKey.lower(sk),
                                                                                            FfiConverterTypeZcashOutPoint.lower(utxo),
                                                                                            FfiConverterTypeZcashTxOut.lower(coin), $0)
            }
    }

    public func addTransparentOutput(to: ZcashTransparentAddress, value: ZcashAmount) {
        try!
            rustCall {
                uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_output(self.pointer,
                                                                                             FfiConverterTypeZcashTransparentAddress.lower(to),
                                                                                             FfiConverterTypeZcashAmount.lower(value), $0)
            }
    }

    public func build(prover: ZcashLocalTxProver, feeRule: ZcashFeeRules) throws -> ZcashTransactionAndSaplingMetadata {
        return try FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_build(self.pointer,
                                                                            FfiConverterTypeZcashLocalTxProver.lower(prover),
                                                                            FfiConverterTypeZcashFeeRules.lower(feeRule), $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTransactionBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransactionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransactionBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransactionBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionBuilder {
        return ZcashTransactionBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransactionBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransactionBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionBuilder {
    return try FfiConverterTypeZcashTransactionBuilder.lift(pointer)
}

public func FfiConverterTypeZcashTransactionBuilder_lower(_ value: ZcashTransactionBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransactionBuilder.lower(value)
}

public protocol ZcashTransactionRequestProtocol {
    func payments() -> [ZcashPayment]

    func toUri(params: ZcashConsensusParameters) -> String?
}

public class ZcashTransactionRequest: ZcashTransactionRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(payments: [ZcashPayment]) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashZip321Error.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_new(
                FfiConverterSequenceTypeZcashPayment.lower(payments), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtransactionrequest(pointer, $0) }
    }

    public static func empty() -> ZcashTransactionRequest {
        return ZcashTransactionRequest(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_empty($0)
        })
    }

    public static func fromUri(params: ZcashConsensusParameters, uri: String) throws -> ZcashTransactionRequest {
        return try ZcashTransactionRequest(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashZip321Error.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_from_uri(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(uri), $0
            )
        })
    }

    public func payments() -> [ZcashPayment] {
        return try! FfiConverterSequenceTypeZcashPayment.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_payments(self.pointer, $0)
                }
        )
    }

    public func toUri(params: ZcashConsensusParameters) -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_to_uri(self.pointer,
                                                                                 FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransactionRequest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransactionRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransactionRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransactionRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionRequest {
        return ZcashTransactionRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransactionRequest) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransactionRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransactionRequest {
    return try FfiConverterTypeZcashTransactionRequest.lift(pointer)
}

public func FfiConverterTypeZcashTransactionRequest_lower(_ value: ZcashTransactionRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransactionRequest.lower(value)
}

public protocol ZcashTransparentAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func isPublicKey() -> Bool

    func isScript() -> Bool

    func script() -> ZcashScript

    func toBytes() -> [UInt8]
}

public class ZcashTransparentAddress: ZcashTransparentAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtransparentaddress(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, input: String) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(input), $0
            )
        })
    }

    public static func fromPublicKey(data: [UInt8]) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_public_key(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func fromScript(data: [UInt8]) throws -> ZcashTransparentAddress {
        return try ZcashTransparentAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_script(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_encode(self.pointer,
                                                                                 FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func isPublicKey() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_public_key(self.pointer, $0)
                }
        )
    }

    public func isScript() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_script(self.pointer, $0)
                }
        )
    }

    public func script() -> ZcashScript {
        return try! FfiConverterTypeZcashScript.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_script(self.pointer, $0)
                }
        )
    }

    public func toBytes() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_to_bytes(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransparentAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransparentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransparentAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentAddress {
        return ZcashTransparentAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransparentAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransparentAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentAddress {
    return try FfiConverterTypeZcashTransparentAddress.lift(pointer)
}

public func FfiConverterTypeZcashTransparentAddress_lower(_ value: ZcashTransparentAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransparentAddress.lower(value)
}

public protocol ZcashTransparentBundleProtocol {
    func isCoinbase() -> Bool

    func vin() -> [ZcashTxIn]

    func vout() -> [ZcashTxOut]
}

public class ZcashTransparentBundle: ZcashTransparentBundleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtransparentbundle(pointer, $0) }
    }

    public func isCoinbase() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_is_coinbase(self.pointer, $0)
                }
        )
    }

    public func vin() -> [ZcashTxIn] {
        return try! FfiConverterSequenceTypeZcashTxIn.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vin(self.pointer, $0)
                }
        )
    }

    public func vout() -> [ZcashTxOut] {
        return try! FfiConverterSequenceTypeZcashTxOut.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vout(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTransparentBundle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTransparentBundle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentBundle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTransparentBundle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentBundle {
        return ZcashTransparentBundle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTransparentBundle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTransparentBundle_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTransparentBundle {
    return try FfiConverterTypeZcashTransparentBundle.lift(pointer)
}

public func FfiConverterTypeZcashTransparentBundle_lower(_ value: ZcashTransparentBundle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTransparentBundle.lower(value)
}

public protocol ZcashTxIdProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashTxId: ZcashTxIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtxid(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashTxId {
        return try ZcashTxId(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtxid_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtxid_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTxId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxId {
        return ZcashTxId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxId_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxId {
    return try FfiConverterTypeZcashTxId.lift(pointer)
}

public func FfiConverterTypeZcashTxId_lower(_ value: ZcashTxId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxId.lower(value)
}

public protocol ZcashTxInProtocol {
    func toBytes() throws -> [UInt8]
}

public class ZcashTxIn: ZcashTxInProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtxin(pointer, $0) }
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtxin_to_bytes(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeZcashTxIn: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxIn

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxIn {
        return ZcashTxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxIn) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxIn {
    return try FfiConverterTypeZcashTxIn.lift(pointer)
}

public func FfiConverterTypeZcashTxIn_lower(_ value: ZcashTxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxIn.lower(value)
}

public protocol ZcashTxOutProtocol {
    func recipientAddress() -> ZcashTransparentAddress?

    func scriptPubkey() -> ZcashScript

    func toBytes() throws -> [UInt8]

    func value() -> ZcashAmount
}

public class ZcashTxOut: ZcashTxOutProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(value: ZcashAmount, scriptPubkey: ZcashScript) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashtxout_new(
                FfiConverterTypeZcashAmount.lower(value),
                FfiConverterTypeZcashScript.lower(scriptPubkey), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtxout(pointer, $0) }
    }

    public func recipientAddress() -> ZcashTransparentAddress? {
        return try! FfiConverterOptionTypeZcashTransparentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxout_recipient_address(self.pointer, $0)
                }
        )
    }

    public func scriptPubkey() -> ZcashScript {
        return try! FfiConverterTypeZcashScript.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxout_script_pubkey(self.pointer, $0)
                }
        )
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtxout_to_bytes(self.pointer, $0)
            }
        )
    }

    public func value() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxout_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTxOut: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxOut

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxOut {
        return ZcashTxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxOut) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxOut {
    return try FfiConverterTypeZcashTxOut.lift(pointer)
}

public func FfiConverterTypeZcashTxOut_lower(_ value: ZcashTxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxOut.lower(value)
}

public protocol ZcashTxVersionProtocol {
    func hasOrchard() -> Bool

    func hasOverwinter() -> Bool

    func hasSapling() -> Bool

    func hasSprout() -> Bool

    func header() -> UInt32

    func selection() -> ZcashTxVersionSelection

    func toBytes() throws -> [UInt8]

    func versionGroupId() -> UInt32
}

public class ZcashTxVersion: ZcashTxVersionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashtxversion(pointer, $0) }
    }

    public static func fromBytes(data: [UInt8]) throws -> ZcashTxVersion {
        return try ZcashTxVersion(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashtxversion_from_bytes(
                FfiConverterSequenceUInt8.lower(data), $0
            )
        })
    }

    public static func suggestedForBranch(consensusBranchId: ZcashBranchId) -> ZcashTxVersion {
        return ZcashTxVersion(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashtxversion_suggested_for_branch(
                FfiConverterTypeZcashBranchId.lower(consensusBranchId), $0
            )
        })
    }

    public func hasOrchard() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_has_orchard(self.pointer, $0)
                }
        )
    }

    public func hasOverwinter() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_has_overwinter(self.pointer, $0)
                }
        )
    }

    public func hasSapling() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sapling(self.pointer, $0)
                }
        )
    }

    public func hasSprout() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sprout(self.pointer, $0)
                }
        )
    }

    public func header() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_header(self.pointer, $0)
                }
        )
    }

    public func selection() -> ZcashTxVersionSelection {
        return try! FfiConverterTypeZcashTxVersionSelection.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_selection(self.pointer, $0)
                }
        )
    }

    public func toBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashtxversion_to_bytes(self.pointer, $0)
            }
        )
    }

    public func versionGroupId() -> UInt32 {
        return try! FfiConverterUInt32.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashtxversion_version_group_id(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashTxVersion: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashTxVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxVersion {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashTxVersion, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxVersion {
        return ZcashTxVersion(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashTxVersion) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashTxVersion_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashTxVersion {
    return try FfiConverterTypeZcashTxVersion.lift(pointer)
}

public func FfiConverterTypeZcashTxVersion_lower(_ value: ZcashTxVersion) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashTxVersion.lower(value)
}

public protocol ZcashUnifiedAddressProtocol {
    func encode(params: ZcashConsensusParameters) -> String

    func orchard() -> ZcashOrchardAddress?

    func sapling() -> ZcashPaymentAddress?

    func transparent() -> ZcashTransparentAddress?
}

public class ZcashUnifiedAddress: ZcashUnifiedAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(orchard: ZcashOrchardAddress?, sapling: ZcashPaymentAddress?, transparent: ZcashTransparentAddress?) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_new(
                FfiConverterOptionTypeZcashOrchardAddress.lower(orchard),
                FfiConverterOptionTypeZcashPaymentAddress.lower(sapling),
                FfiConverterOptionTypeZcashTransparentAddress.lower(transparent), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashunifiedaddress(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, address: String) throws -> ZcashUnifiedAddress {
        return try ZcashUnifiedAddress(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(address), $0
            )
        })
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_encode(self.pointer,
                                                                             FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func orchard() -> ZcashOrchardAddress? {
        return try! FfiConverterOptionTypeZcashOrchardAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_orchard(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_sapling(self.pointer, $0)
                }
        )
    }

    public func transparent() -> ZcashTransparentAddress? {
        return try! FfiConverterOptionTypeZcashTransparentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_transparent(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedAddress {
        return ZcashUnifiedAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedAddress {
    return try FfiConverterTypeZcashUnifiedAddress.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedAddress_lower(_ value: ZcashUnifiedAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedAddress.lower(value)
}

public protocol ZcashUnifiedFullViewingKeyProtocol {
    func address(j: ZcashDiversifierIndex) -> ZcashUnifiedAddress?

    func defaultAddress() -> ZcashUnifiedAddressAndDiversifierIndex

    func encode(params: ZcashConsensusParameters) -> String

    func findAddress(j: ZcashDiversifierIndex) -> ZcashUnifiedAddressAndDiversifierIndex?

    func orchard() -> ZcashOrchardFullViewingKey?

    func sapling() -> ZcashDiversifiableFullViewingKey?

    func transparent() -> ZcashAccountPubKey?
}

public class ZcashUnifiedFullViewingKey: ZcashUnifiedFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(transparent: ZcashAccountPubKey?, sapling: ZcashDiversifiableFullViewingKey?, orchard: ZcashOrchardFullViewingKey?) throws {
        try self.init(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_new(
                FfiConverterOptionTypeZcashAccountPubKey.lower(transparent),
                FfiConverterOptionTypeZcashDiversifiableFullViewingKey.lower(sapling),
                FfiConverterOptionTypeZcashOrchardFullViewingKey.lower(orchard), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashunifiedfullviewingkey(pointer, $0) }
    }

    public static func decode(params: ZcashConsensusParameters, encoded: String) throws -> ZcashUnifiedFullViewingKey {
        return try ZcashUnifiedFullViewingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_decode(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterString.lower(encoded), $0
            )
        })
    }

    public func address(j: ZcashDiversifierIndex) -> ZcashUnifiedAddress? {
        return try! FfiConverterOptionTypeZcashUnifiedAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_address(self.pointer,
                                                                                     FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func defaultAddress() -> ZcashUnifiedAddressAndDiversifierIndex {
        return try! FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_default_address(self.pointer, $0)
                }
        )
    }

    public func encode(params: ZcashConsensusParameters) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_encode(self.pointer,
                                                                                    FfiConverterTypeZcashConsensusParameters.lower(params), $0)
                }
        )
    }

    public func findAddress(j: ZcashDiversifierIndex) -> ZcashUnifiedAddressAndDiversifierIndex? {
        return try! FfiConverterOptionTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_find_address(self.pointer,
                                                                                          FfiConverterTypeZcashDiversifierIndex.lower(j), $0)
                }
        )
    }

    public func orchard() -> ZcashOrchardFullViewingKey? {
        return try! FfiConverterOptionTypeZcashOrchardFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_orchard(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashDiversifiableFullViewingKey? {
        return try! FfiConverterOptionTypeZcashDiversifiableFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_sapling(self.pointer, $0)
                }
        )
    }

    public func transparent() -> ZcashAccountPubKey? {
        return try! FfiConverterOptionTypeZcashAccountPubKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_transparent(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedFullViewingKey {
        return ZcashUnifiedFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedFullViewingKey {
    return try FfiConverterTypeZcashUnifiedFullViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedFullViewingKey_lower(_ value: ZcashUnifiedFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedFullViewingKey.lower(value)
}

public protocol ZcashUnifiedSpendingKeyProtocol {
    func orchard() -> ZcashOrchardSpendingKey

    func sapling() -> ZcashExtendedSpendingKey

    func toBytes(era: ZcashKeysEra) -> [UInt8]

    func toUnifiedFullViewingKey() -> ZcashUnifiedFullViewingKey

    func transparent() -> ZcashAccountPrivKey
}

public class ZcashUnifiedSpendingKey: ZcashUnifiedSpendingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashunifiedspendingkey(pointer, $0) }
    }

    public static func fromBytes(era: ZcashKeysEra, encoded: [UInt8]) throws -> ZcashUnifiedSpendingKey {
        return try ZcashUnifiedSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_bytes(
                FfiConverterTypeZcashKeysEra.lower(era),
                FfiConverterSequenceUInt8.lower(encoded), $0
            )
        })
    }

    public static func fromSeed(params: ZcashConsensusParameters, seed: [UInt8], accountId: ZcashAccountId) throws -> ZcashUnifiedSpendingKey {
        return try ZcashUnifiedSpendingKey(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_seed(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterSequenceUInt8.lower(seed),
                FfiConverterTypeZcashAccountId.lower(accountId), $0
            )
        })
    }

    public func orchard() -> ZcashOrchardSpendingKey {
        return try! FfiConverterTypeZcashOrchardSpendingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_orchard(self.pointer, $0)
                }
        )
    }

    public func sapling() -> ZcashExtendedSpendingKey {
        return try! FfiConverterTypeZcashExtendedSpendingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_sapling(self.pointer, $0)
                }
        )
    }

    public func toBytes(era: ZcashKeysEra) -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_bytes(self.pointer,
                                                                                   FfiConverterTypeZcashKeysEra.lower(era), $0)
                }
        )
    }

    public func toUnifiedFullViewingKey() -> ZcashUnifiedFullViewingKey {
        return try! FfiConverterTypeZcashUnifiedFullViewingKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_unified_full_viewing_key(self.pointer, $0)
                }
        )
    }

    public func transparent() -> ZcashAccountPrivKey {
        return try! FfiConverterTypeZcashAccountPrivKey.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_transparent(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashUnifiedSpendingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashUnifiedSpendingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedSpendingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashUnifiedSpendingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedSpendingKey {
        return ZcashUnifiedSpendingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashUnifiedSpendingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashUnifiedSpendingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashUnifiedSpendingKey {
    return try FfiConverterTypeZcashUnifiedSpendingKey.lift(pointer)
}

public func FfiConverterTypeZcashUnifiedSpendingKey_lower(_ value: ZcashUnifiedSpendingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashUnifiedSpendingKey.lower(value)
}

public protocol ZcashVerifyingKeyProtocol {}

public class ZcashVerifyingKey: ZcashVerifyingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashverifyingkey_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashverifyingkey(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashVerifyingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashVerifyingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashVerifyingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashVerifyingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashVerifyingKey {
        return ZcashVerifyingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashVerifyingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashVerifyingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashVerifyingKey {
    return try FfiConverterTypeZcashVerifyingKey.lift(pointer)
}

public func FfiConverterTypeZcashVerifyingKey_lower(_ value: ZcashVerifyingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashVerifyingKey.lower(value)
}

public protocol ZcashViewingKeyProtocol {
    func ivk() -> ZcashSaplingIvk

    func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress?
}

public class ZcashViewingKey: ZcashViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashviewingkey(pointer, $0) }
    }

    public func ivk() -> ZcashSaplingIvk {
        return try! FfiConverterTypeZcashSaplingIvk.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashviewingkey_ivk(self.pointer, $0)
                }
        )
    }

    public func toPaymentAddress(diversifier: ZcashDiversifier) -> ZcashPaymentAddress? {
        return try! FfiConverterOptionTypeZcashPaymentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashviewingkey_to_payment_address(self.pointer,
                                                                                     FfiConverterTypeZcashDiversifier.lower(diversifier), $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashViewingKey {
        return ZcashViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashViewingKey {
    return try FfiConverterTypeZcashViewingKey.lift(pointer)
}

public func FfiConverterTypeZcashViewingKey_lower(_ value: ZcashViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashViewingKey.lower(value)
}

public protocol ZcashWalletProtocol {
    func initWalletDb(zwdb: ZcashWalletDb, seed: [UInt8], params: ZcashConsensusParameters) throws
}

public class ZcashWallet: ZcashWalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashwallet(pointer, $0) }
    }

    public func initWalletDb(zwdb: ZcashWalletDb, seed: [UInt8], params: ZcashConsensusParameters) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwallet_init_wallet_db(self.pointer,
                                                                         FfiConverterTypeZcashWalletDb.lower(zwdb),
                                                                         FfiConverterSequenceUInt8.lower(seed),
                                                                         FfiConverterTypeZcashConsensusParameters.lower(params), $0)
            }
    }
}

public struct FfiConverterTypeZcashWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashWallet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashWallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashWallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWallet {
        return ZcashWallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashWallet) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWallet {
    return try FfiConverterTypeZcashWallet.lift(pointer)
}

public func FfiConverterTypeZcashWallet_lower(_ value: ZcashWallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashWallet.lower(value)
}

public protocol ZcashWalletDbProtocol {
    func getAccountForUfvk(zufvk: ZcashUnifiedFullViewingKey) throws -> ZcashAccountId?

    func getCurrentAddress(aid: ZcashAccountId) throws -> ZcashUnifiedAddress?

    func getMinUnspentHeight() throws -> ZcashBlockHeight?

    func getTransparentReceivers(aid: ZcashAccountId) throws -> [String: ZcashAddressMetadata]

    func getUnspentTransparentOutputs(zta: ZcashTransparentAddress, zbh: ZcashBlockHeight, zop: [ZcashOutPoint]) throws -> [ZcashWalletTransparentOutput]

    func getWalletSummary(minConfirmations: UInt32) throws -> ZcashWalletSummary?

    func putReceivedTransparentUtxo(output: ZcashWalletTransparentOutput) throws -> Int64

    func putSaplingSubtreeRoots(startIndex: UInt64, roots: [ZcashCommitmentTreeRoot]) throws

    func storeDecryptedTx(dTx: ZcashDecryptedTransaction) throws

    func suggestScanRanges() throws -> [ZcashScanRange]

    func truncateToHeight(blockHeight: UInt32) throws

    func updateChainTip(tipHeight: UInt32) throws
}

public class ZcashWalletDb: ZcashWalletDbProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashwalletdb(pointer, $0) }
    }

    public static func forPath(path: String, params: ZcashConsensusParameters) throws -> ZcashWalletDb {
        return try ZcashWalletDb(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashwalletdb_for_path(
                FfiConverterString.lower(path),
                FfiConverterTypeZcashConsensusParameters.lower(params), $0
            )
        })
    }

    public func getAccountForUfvk(zufvk: ZcashUnifiedFullViewingKey) throws -> ZcashAccountId? {
        return try FfiConverterOptionTypeZcashAccountId.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_account_for_ufvk(self.pointer,
                                                                                 FfiConverterTypeZcashUnifiedFullViewingKey.lower(zufvk), $0)
            }
        )
    }

    public func getCurrentAddress(aid: ZcashAccountId) throws -> ZcashUnifiedAddress? {
        return try FfiConverterOptionTypeZcashUnifiedAddress.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_current_address(self.pointer,
                                                                                FfiConverterTypeZcashAccountId.lower(aid), $0)
            }
        )
    }

    public func getMinUnspentHeight() throws -> ZcashBlockHeight? {
        return try FfiConverterOptionTypeZcashBlockHeight.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_min_unspent_height(self.pointer, $0)
            }
        )
    }

    public func getTransparentReceivers(aid: ZcashAccountId) throws -> [String: ZcashAddressMetadata] {
        return try FfiConverterDictionaryStringTypeZcashAddressMetadata.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transparent_receivers(self.pointer,
                                                                                      FfiConverterTypeZcashAccountId.lower(aid), $0)
            }
        )
    }

    public func getUnspentTransparentOutputs(zta: ZcashTransparentAddress, zbh: ZcashBlockHeight, zop: [ZcashOutPoint]) throws -> [ZcashWalletTransparentOutput] {
        return try FfiConverterSequenceTypeZcashWalletTransparentOutput.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_unspent_transparent_outputs(self.pointer,
                                                                                            FfiConverterTypeZcashTransparentAddress.lower(zta),
                                                                                            FfiConverterTypeZcashBlockHeight.lower(zbh),
                                                                                            FfiConverterSequenceTypeZcashOutPoint.lower(zop), $0)
            }
        )
    }

    public func getWalletSummary(minConfirmations: UInt32) throws -> ZcashWalletSummary? {
        return try FfiConverterOptionTypeZcashWalletSummary.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_wallet_summary(self.pointer,
                                                                               FfiConverterUInt32.lower(minConfirmations), $0)
            }
        )
    }

    public func putReceivedTransparentUtxo(output: ZcashWalletTransparentOutput) throws -> Int64 {
        return try FfiConverterInt64.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_received_transparent_utxo(self.pointer,
                                                                                          FfiConverterTypeZcashWalletTransparentOutput.lower(output), $0)
            }
        )
    }

    public func putSaplingSubtreeRoots(startIndex: UInt64, roots: [ZcashCommitmentTreeRoot]) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_sapling_subtree_roots(self.pointer,
                                                                                      FfiConverterUInt64.lower(startIndex),
                                                                                      FfiConverterSequenceTypeZcashCommitmentTreeRoot.lower(roots), $0)
            }
    }

    public func storeDecryptedTx(dTx: ZcashDecryptedTransaction) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_store_decrypted_tx(self.pointer,
                                                                               FfiConverterTypeZcashDecryptedTransaction.lower(dTx), $0)
            }
    }

    public func suggestScanRanges() throws -> [ZcashScanRange] {
        return try FfiConverterSequenceTypeZcashScanRange.lift(
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_suggest_scan_ranges(self.pointer, $0)
            }
        )
    }

    public func truncateToHeight(blockHeight: UInt32) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_truncate_to_height(self.pointer,
                                                                               FfiConverterUInt32.lower(blockHeight), $0)
            }
    }

    public func updateChainTip(tipHeight: UInt32) throws {
        try
            rustCallWithError(FfiConverterTypeZcashError.lift) {
                uniffi_uniffi_zcash_fn_method_zcashwalletdb_update_chain_tip(self.pointer,
                                                                             FfiConverterUInt32.lower(tipHeight), $0)
            }
    }
}

public struct FfiConverterTypeZcashWalletDb: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashWalletDb

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashWalletDb {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashWalletDb, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletDb {
        return ZcashWalletDb(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashWalletDb) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashWalletDb_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletDb {
    return try FfiConverterTypeZcashWalletDb.lift(pointer)
}

public func FfiConverterTypeZcashWalletDb_lower(_ value: ZcashWalletDb) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashWalletDb.lower(value)
}

public protocol ZcashWalletSummaryProtocol {
    func accountBalances() -> [String: ZcashAccountBalance]

    func chainTipHeight() -> ZcashBlockHeight

    func fullyScannedHeight() -> ZcashBlockHeight

    func isSynced() -> Bool

    func scanProgress() -> ZcashRatio?
}

public class ZcashWalletSummary: ZcashWalletSummaryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(accountBalances: [String: ZcashAccountBalance], chainTipHeight: ZcashBlockHeight, fullyScannedHeight: ZcashBlockHeight, scanProgress: ZcashRatio?) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashwalletsummary_new(
                FfiConverterDictionaryStringTypeZcashAccountBalance.lower(accountBalances),
                FfiConverterTypeZcashBlockHeight.lower(chainTipHeight),
                FfiConverterTypeZcashBlockHeight.lower(fullyScannedHeight),
                FfiConverterOptionTypeZcashRatio.lower(scanProgress), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashwalletsummary(pointer, $0) }
    }

    public func accountBalances() -> [String: ZcashAccountBalance] {
        return try! FfiConverterDictionaryStringTypeZcashAccountBalance.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwalletsummary_account_balances(self.pointer, $0)
                }
        )
    }

    public func chainTipHeight() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwalletsummary_chain_tip_height(self.pointer, $0)
                }
        )
    }

    public func fullyScannedHeight() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwalletsummary_fully_scanned_height(self.pointer, $0)
                }
        )
    }

    public func isSynced() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwalletsummary_is_synced(self.pointer, $0)
                }
        )
    }

    public func scanProgress() -> ZcashRatio? {
        return try! FfiConverterOptionTypeZcashRatio.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwalletsummary_scan_progress(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashWalletSummary: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashWalletSummary

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashWalletSummary {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashWalletSummary, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletSummary {
        return ZcashWalletSummary(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashWalletSummary) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashWalletSummary_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletSummary {
    return try FfiConverterTypeZcashWalletSummary.lift(pointer)
}

public func FfiConverterTypeZcashWalletSummary_lower(_ value: ZcashWalletSummary) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashWalletSummary.lower(value)
}

public protocol ZcashWalletTransparentOutputProtocol {
    func height() -> ZcashBlockHeight

    func outpoint() -> ZcashOutPoint

    func recipientAddress() -> ZcashTransparentAddress

    func txout() -> ZcashTxOut

    func value() -> ZcashAmount
}

public class ZcashWalletTransparentOutput: ZcashWalletTransparentOutputProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashwallettransparentoutput(pointer, $0) }
    }

    public static func fromParts(outpoint: ZcashOutPoint, txout: ZcashTxOut, height: ZcashBlockHeight) throws -> ZcashWalletTransparentOutput {
        return try ZcashWalletTransparentOutput(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashwallettransparentoutput_from_parts(
                FfiConverterTypeZcashOutPoint.lower(outpoint),
                FfiConverterTypeZcashTxOut.lower(txout),
                FfiConverterTypeZcashBlockHeight.lower(height), $0
            )
        })
    }

    public func height() -> ZcashBlockHeight {
        return try! FfiConverterTypeZcashBlockHeight.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_height(self.pointer, $0)
                }
        )
    }

    public func outpoint() -> ZcashOutPoint {
        return try! FfiConverterTypeZcashOutPoint.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_outpoint(self.pointer, $0)
                }
        )
    }

    public func recipientAddress() -> ZcashTransparentAddress {
        return try! FfiConverterTypeZcashTransparentAddress.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_recipient_address(self.pointer, $0)
                }
        )
    }

    public func txout() -> ZcashTxOut {
        return try! FfiConverterTypeZcashTxOut.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_txout(self.pointer, $0)
                }
        )
    }

    public func value() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashWalletTransparentOutput: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashWalletTransparentOutput

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashWalletTransparentOutput {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashWalletTransparentOutput, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletTransparentOutput {
        return ZcashWalletTransparentOutput(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashWalletTransparentOutput) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashWalletTransparentOutput_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashWalletTransparentOutput {
    return try FfiConverterTypeZcashWalletTransparentOutput.lift(pointer)
}

public func FfiConverterTypeZcashWalletTransparentOutput_lower(_ value: ZcashWalletTransparentOutput) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashWalletTransparentOutput.lower(value)
}

public protocol ZcashZip317FeeRuleProtocol {
    func marginalFee() -> ZcashAmount
}

public class ZcashZip317FeeRule: ZcashZip317FeeRuleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashzip317feerule(pointer, $0) }
    }

    public static func nonStandard(marginalFee: ZcashAmount, graceActions: UInt64, p2pkhStandardInputSize: UInt64, p2pkhStandardOutputSize: UInt64) throws -> ZcashZip317FeeRule {
        return try ZcashZip317FeeRule(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_non_standard(
                FfiConverterTypeZcashAmount.lower(marginalFee),
                FfiConverterUInt64.lower(graceActions),
                FfiConverterUInt64.lower(p2pkhStandardInputSize),
                FfiConverterUInt64.lower(p2pkhStandardOutputSize), $0
            )
        })
    }

    public static func standard() -> ZcashZip317FeeRule {
        return ZcashZip317FeeRule(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_standard($0)
        })
    }

    public func marginalFee() -> ZcashAmount {
        return try! FfiConverterTypeZcashAmount.lift(
            try!
                rustCall {
                    uniffi_uniffi_zcash_fn_method_zcashzip317feerule_marginal_fee(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeZcashZip317FeeRule: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashZip317FeeRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashZip317FeeRule {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashZip317FeeRule, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317FeeRule {
        return ZcashZip317FeeRule(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashZip317FeeRule) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashZip317FeeRule_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317FeeRule {
    return try FfiConverterTypeZcashZip317FeeRule.lift(pointer)
}

public func FfiConverterTypeZcashZip317FeeRule_lower(_ value: ZcashZip317FeeRule) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashZip317FeeRule.lower(value)
}

public protocol ZcashZip317SingleOutputChangeStrategyProtocol {}

public class ZcashZip317SingleOutputChangeStrategy: ZcashZip317SingleOutputChangeStrategyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(feeRule: ZcashZip317FeeRule) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_uniffi_zcash_fn_constructor_zcashzip317singleoutputchangestrategy_new(
                FfiConverterTypeZcashZip317FeeRule.lower(feeRule), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_uniffi_zcash_fn_free_zcashzip317singleoutputchangestrategy(pointer, $0) }
    }
}

public struct FfiConverterTypeZcashZip317SingleOutputChangeStrategy: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZcashZip317SingleOutputChangeStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashZip317SingleOutputChangeStrategy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZcashZip317SingleOutputChangeStrategy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317SingleOutputChangeStrategy {
        return ZcashZip317SingleOutputChangeStrategy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZcashZip317SingleOutputChangeStrategy) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeZcashZip317SingleOutputChangeStrategy_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZcashZip317SingleOutputChangeStrategy {
    return try FfiConverterTypeZcashZip317SingleOutputChangeStrategy.lift(pointer)
}

public func FfiConverterTypeZcashZip317SingleOutputChangeStrategy_lower(_ value: ZcashZip317SingleOutputChangeStrategy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZcashZip317SingleOutputChangeStrategy.lower(value)
}

public struct ZcashAccountId {
    public var id: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt32) {
        self.id = id
    }
}

extension ZcashAccountId: Equatable, Hashable {
    public static func == (lhs: ZcashAccountId, rhs: ZcashAccountId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

public struct FfiConverterTypeZcashAccountId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAccountId {
        return try ZcashAccountId(
            id: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashAccountId, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.id, into: &buf)
    }
}

public func FfiConverterTypeZcashAccountId_lift(_ buf: RustBuffer) throws -> ZcashAccountId {
    return try FfiConverterTypeZcashAccountId.lift(buf)
}

public func FfiConverterTypeZcashAccountId_lower(_ value: ZcashAccountId) -> RustBuffer {
    return FfiConverterTypeZcashAccountId.lower(value)
}

public struct ZcashAuthPath {
    public var node: ZcashSaplingNode

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(node: ZcashSaplingNode) {
        self.node = node
    }
}

public struct FfiConverterTypeZcashAuthPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashAuthPath {
        return try ZcashAuthPath(
            node: FfiConverterTypeZcashSaplingNode.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashAuthPath, into buf: inout [UInt8]) {
        FfiConverterTypeZcashSaplingNode.write(value.node, into: &buf)
    }
}

public func FfiConverterTypeZcashAuthPath_lift(_ buf: RustBuffer) throws -> ZcashAuthPath {
    return try FfiConverterTypeZcashAuthPath.lift(buf)
}

public func FfiConverterTypeZcashAuthPath_lower(_ value: ZcashAuthPath) -> RustBuffer {
    return FfiConverterTypeZcashAuthPath.lower(value)
}

public struct ZcashDiversifierIndexAndPaymentAddress {
    public var diversifierIndex: ZcashDiversifierIndex
    public var address: ZcashPaymentAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(diversifierIndex: ZcashDiversifierIndex, address: ZcashPaymentAddress) {
        self.diversifierIndex = diversifierIndex
        self.address = address
    }
}

public struct FfiConverterTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndexAndPaymentAddress {
        return try ZcashDiversifierIndexAndPaymentAddress(
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf),
            address: FfiConverterTypeZcashPaymentAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashDiversifierIndexAndPaymentAddress, into buf: inout [UInt8]) {
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
        FfiConverterTypeZcashPaymentAddress.write(value.address, into: &buf)
    }
}

public func FfiConverterTypeZcashDiversifierIndexAndPaymentAddress_lift(_ buf: RustBuffer) throws -> ZcashDiversifierIndexAndPaymentAddress {
    return try FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(buf)
}

public func FfiConverterTypeZcashDiversifierIndexAndPaymentAddress_lower(_ value: ZcashDiversifierIndexAndPaymentAddress) -> RustBuffer {
    return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lower(value)
}

public struct ZcashDiversifierIndexAndScope {
    public var diversifierIndex: ZcashDiversifierIndex
    public var scope: ZcashScope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(diversifierIndex: ZcashDiversifierIndex, scope: ZcashScope) {
        self.diversifierIndex = diversifierIndex
        self.scope = scope
    }
}

public struct FfiConverterTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDiversifierIndexAndScope {
        return try ZcashDiversifierIndexAndScope(
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf),
            scope: FfiConverterTypeZcashScope.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashDiversifierIndexAndScope, into buf: inout [UInt8]) {
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
        FfiConverterTypeZcashScope.write(value.scope, into: &buf)
    }
}

public func FfiConverterTypeZcashDiversifierIndexAndScope_lift(_ buf: RustBuffer) throws -> ZcashDiversifierIndexAndScope {
    return try FfiConverterTypeZcashDiversifierIndexAndScope.lift(buf)
}

public func FfiConverterTypeZcashDiversifierIndexAndScope_lower(_ value: ZcashDiversifierIndexAndScope) -> RustBuffer {
    return FfiConverterTypeZcashDiversifierIndexAndScope.lower(value)
}

public struct ZcashInternalOvkExternalOvk {
    public var internalOvk: ZcashInternalOvk
    public var externalOvk: ZcashExternalOvk

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(internalOvk: ZcashInternalOvk, externalOvk: ZcashExternalOvk) {
        self.internalOvk = internalOvk
        self.externalOvk = externalOvk
    }
}

public struct FfiConverterTypeZcashInternalOvkExternalOvk: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashInternalOvkExternalOvk {
        return try ZcashInternalOvkExternalOvk(
            internalOvk: FfiConverterTypeZcashInternalOvk.read(from: &buf),
            externalOvk: FfiConverterTypeZcashExternalOvk.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashInternalOvkExternalOvk, into buf: inout [UInt8]) {
        FfiConverterTypeZcashInternalOvk.write(value.internalOvk, into: &buf)
        FfiConverterTypeZcashExternalOvk.write(value.externalOvk, into: &buf)
    }
}

public func FfiConverterTypeZcashInternalOvkExternalOvk_lift(_ buf: RustBuffer) throws -> ZcashInternalOvkExternalOvk {
    return try FfiConverterTypeZcashInternalOvkExternalOvk.lift(buf)
}

public func FfiConverterTypeZcashInternalOvkExternalOvk_lower(_ value: ZcashInternalOvkExternalOvk) -> RustBuffer {
    return FfiConverterTypeZcashInternalOvkExternalOvk.lower(value)
}

public struct ZcashOrchardDecryptOutput {
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutput {
        return try ZcashOrchardDecryptOutput(
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutput, into buf: inout [UInt8]) {
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutput_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutput {
    return try FfiConverterTypeZcashOrchardDecryptOutput.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutput_lower(_ value: ZcashOrchardDecryptOutput) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutput.lower(value)
}

public struct ZcashOrchardDecryptOutputForIncomingKeys {
    public var idx: UInt64
    public var key: ZcashOrchardIncomingViewingKey
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: UInt64, key: ZcashOrchardIncomingViewingKey, note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutputForIncomingKeys {
        return try ZcashOrchardDecryptOutputForIncomingKeys(
            idx: FfiConverterUInt64.read(from: &buf),
            key: FfiConverterTypeZcashOrchardIncomingViewingKey.read(from: &buf),
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutputForIncomingKeys, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.idx, into: &buf)
        FfiConverterTypeZcashOrchardIncomingViewingKey.write(value.key, into: &buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutputForIncomingKeys {
    return try FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys_lower(_ value: ZcashOrchardDecryptOutputForIncomingKeys) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.lower(value)
}

public struct ZcashOrchardDecryptOutputForOutgoingKeys {
    public var idx: UInt64
    public var key: ZcashOrchardOutgoingViewingKey
    public var note: ZcashOrchardNote
    public var address: ZcashOrchardAddress
    public var data: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(idx: UInt64, key: ZcashOrchardOutgoingViewingKey, note: ZcashOrchardNote, address: ZcashOrchardAddress, data: [UInt8]) {
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data
    }
}

public struct FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardDecryptOutputForOutgoingKeys {
        return try ZcashOrchardDecryptOutputForOutgoingKeys(
            idx: FfiConverterUInt64.read(from: &buf),
            key: FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf),
            note: FfiConverterTypeZcashOrchardNote.read(from: &buf),
            address: FfiConverterTypeZcashOrchardAddress.read(from: &buf),
            data: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardDecryptOutputForOutgoingKeys, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.idx, into: &buf)
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value.key, into: &buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, into: &buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, into: &buf)
        FfiConverterSequenceUInt8.write(value.data, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys_lift(_ buf: RustBuffer) throws -> ZcashOrchardDecryptOutputForOutgoingKeys {
    return try FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(buf)
}

public func FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys_lower(_ value: ZcashOrchardDecryptOutputForOutgoingKeys) -> RustBuffer {
    return FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.lower(value)
}

public struct ZcashOrchardTransmittedNoteCiphertext {
    public var epkBytes: [UInt8]
    public var encCiphertext: [UInt8]
    public var outCiphertext: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epkBytes: [UInt8], encCiphertext: [UInt8], outCiphertext: [UInt8]) {
        self.epkBytes = epkBytes
        self.encCiphertext = encCiphertext
        self.outCiphertext = outCiphertext
    }
}

extension ZcashOrchardTransmittedNoteCiphertext: Equatable, Hashable {
    public static func == (lhs: ZcashOrchardTransmittedNoteCiphertext, rhs: ZcashOrchardTransmittedNoteCiphertext) -> Bool {
        if lhs.epkBytes != rhs.epkBytes {
            return false
        }
        if lhs.encCiphertext != rhs.encCiphertext {
            return false
        }
        if lhs.outCiphertext != rhs.outCiphertext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(epkBytes)
        hasher.combine(encCiphertext)
        hasher.combine(outCiphertext)
    }
}

public struct FfiConverterTypeZcashOrchardTransmittedNoteCiphertext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardTransmittedNoteCiphertext {
        return try ZcashOrchardTransmittedNoteCiphertext(
            epkBytes: FfiConverterSequenceUInt8.read(from: &buf),
            encCiphertext: FfiConverterSequenceUInt8.read(from: &buf),
            outCiphertext: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashOrchardTransmittedNoteCiphertext, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.epkBytes, into: &buf)
        FfiConverterSequenceUInt8.write(value.encCiphertext, into: &buf)
        FfiConverterSequenceUInt8.write(value.outCiphertext, into: &buf)
    }
}

public func FfiConverterTypeZcashOrchardTransmittedNoteCiphertext_lift(_ buf: RustBuffer) throws -> ZcashOrchardTransmittedNoteCiphertext {
    return try FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(buf)
}

public func FfiConverterTypeZcashOrchardTransmittedNoteCiphertext_lower(_ value: ZcashOrchardTransmittedNoteCiphertext) -> RustBuffer {
    return FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lower(value)
}

public struct ZcashPayment {
    public var recipientAddress: ZcashRecipientAddress
    public var amount: ZcashAmount
    public var memo: ZcashMemoBytes?
    public var label: String?
    public var message: String?
    public var otherParams: [ZcashPaymentParam]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipientAddress: ZcashRecipientAddress, amount: ZcashAmount, memo: ZcashMemoBytes?, label: String?, message: String?, otherParams: [ZcashPaymentParam]) {
        self.recipientAddress = recipientAddress
        self.amount = amount
        self.memo = memo
        self.label = label
        self.message = message
        self.otherParams = otherParams
    }
}

public struct FfiConverterTypeZcashPayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPayment {
        return try ZcashPayment(
            recipientAddress: FfiConverterTypeZcashRecipientAddress.read(from: &buf),
            amount: FfiConverterTypeZcashAmount.read(from: &buf),
            memo: FfiConverterOptionTypeZcashMemoBytes.read(from: &buf),
            label: FfiConverterOptionString.read(from: &buf),
            message: FfiConverterOptionString.read(from: &buf),
            otherParams: FfiConverterSequenceTypeZcashPaymentParam.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashPayment, into buf: inout [UInt8]) {
        FfiConverterTypeZcashRecipientAddress.write(value.recipientAddress, into: &buf)
        FfiConverterTypeZcashAmount.write(value.amount, into: &buf)
        FfiConverterOptionTypeZcashMemoBytes.write(value.memo, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterSequenceTypeZcashPaymentParam.write(value.otherParams, into: &buf)
    }
}

public func FfiConverterTypeZcashPayment_lift(_ buf: RustBuffer) throws -> ZcashPayment {
    return try FfiConverterTypeZcashPayment.lift(buf)
}

public func FfiConverterTypeZcashPayment_lower(_ value: ZcashPayment) -> RustBuffer {
    return FfiConverterTypeZcashPayment.lower(value)
}

public struct ZcashPaymentParam {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}

extension ZcashPaymentParam: Equatable, Hashable {
    public static func == (lhs: ZcashPaymentParam, rhs: ZcashPaymentParam) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}

public struct FfiConverterTypeZcashPaymentParam: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashPaymentParam {
        return try ZcashPaymentParam(
            key: FfiConverterString.read(from: &buf),
            value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashPaymentParam, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeZcashPaymentParam_lift(_ buf: RustBuffer) throws -> ZcashPaymentParam {
    return try FfiConverterTypeZcashPaymentParam.lift(buf)
}

public func FfiConverterTypeZcashPaymentParam_lower(_ value: ZcashPaymentParam) -> RustBuffer {
    return FfiConverterTypeZcashPaymentParam.lower(value)
}

public struct ZcashTransactionAndSaplingMetadata {
    public var transaction: ZcashTransaction
    public var saplingMetadata: ZcashSaplingMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: ZcashTransaction, saplingMetadata: ZcashSaplingMetadata) {
        self.transaction = transaction
        self.saplingMetadata = saplingMetadata
    }
}

public struct FfiConverterTypeZcashTransactionAndSaplingMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransactionAndSaplingMetadata {
        return try ZcashTransactionAndSaplingMetadata(
            transaction: FfiConverterTypeZcashTransaction.read(from: &buf),
            saplingMetadata: FfiConverterTypeZcashSaplingMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashTransactionAndSaplingMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeZcashTransaction.write(value.transaction, into: &buf)
        FfiConverterTypeZcashSaplingMetadata.write(value.saplingMetadata, into: &buf)
    }
}

public func FfiConverterTypeZcashTransactionAndSaplingMetadata_lift(_ buf: RustBuffer) throws -> ZcashTransactionAndSaplingMetadata {
    return try FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(buf)
}

public func FfiConverterTypeZcashTransactionAndSaplingMetadata_lower(_ value: ZcashTransactionAndSaplingMetadata) -> RustBuffer {
    return FfiConverterTypeZcashTransactionAndSaplingMetadata.lower(value)
}

public struct ZcashTransparentAddressAndIndex {
    public var transparentAddress: ZcashTransparentAddress
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transparentAddress: ZcashTransparentAddress, index: UInt32) {
        self.transparentAddress = transparentAddress
        self.index = index
    }
}

public struct FfiConverterTypeZcashTransparentAddressAndIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTransparentAddressAndIndex {
        return try ZcashTransparentAddressAndIndex(
            transparentAddress: FfiConverterTypeZcashTransparentAddress.read(from: &buf),
            index: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashTransparentAddressAndIndex, into buf: inout [UInt8]) {
        FfiConverterTypeZcashTransparentAddress.write(value.transparentAddress, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeZcashTransparentAddressAndIndex_lift(_ buf: RustBuffer) throws -> ZcashTransparentAddressAndIndex {
    return try FfiConverterTypeZcashTransparentAddressAndIndex.lift(buf)
}

public func FfiConverterTypeZcashTransparentAddressAndIndex_lower(_ value: ZcashTransparentAddressAndIndex) -> RustBuffer {
    return FfiConverterTypeZcashTransparentAddressAndIndex.lower(value)
}

public struct ZcashUnifiedAddressAndDiversifierIndex {
    public var address: ZcashUnifiedAddress
    public var diversifierIndex: ZcashDiversifierIndex

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: ZcashUnifiedAddress, diversifierIndex: ZcashDiversifierIndex) {
        self.address = address
        self.diversifierIndex = diversifierIndex
    }
}

public struct FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashUnifiedAddressAndDiversifierIndex {
        return try ZcashUnifiedAddressAndDiversifierIndex(
            address: FfiConverterTypeZcashUnifiedAddress.read(from: &buf),
            diversifierIndex: FfiConverterTypeZcashDiversifierIndex.read(from: &buf)
        )
    }

    public static func write(_ value: ZcashUnifiedAddressAndDiversifierIndex, into buf: inout [UInt8]) {
        FfiConverterTypeZcashUnifiedAddress.write(value.address, into: &buf)
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifierIndex, into: &buf)
    }
}

public func FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex_lift(_ buf: RustBuffer) throws -> ZcashUnifiedAddressAndDiversifierIndex {
    return try FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(buf)
}

public func FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex_lower(_ value: ZcashUnifiedAddressAndDiversifierIndex) -> RustBuffer {
    return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashBranchId {
    case sprout

    case overwinter

    case sapling

    case blossom

    case heartwood

    case canopy

    case nu5
}

public struct FfiConverterTypeZcashBranchId: FfiConverterRustBuffer {
    typealias SwiftType = ZcashBranchId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashBranchId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sprout

        case 2: return .overwinter

        case 3: return .sapling

        case 4: return .blossom

        case 5: return .heartwood

        case 6: return .canopy

        case 7: return .nu5

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashBranchId, into buf: inout [UInt8]) {
        switch value {
        case .sprout:
            writeInt(&buf, Int32(1))

        case .overwinter:
            writeInt(&buf, Int32(2))

        case .sapling:
            writeInt(&buf, Int32(3))

        case .blossom:
            writeInt(&buf, Int32(4))

        case .heartwood:
            writeInt(&buf, Int32(5))

        case .canopy:
            writeInt(&buf, Int32(6))

        case .nu5:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeZcashBranchId_lift(_ buf: RustBuffer) throws -> ZcashBranchId {
    return try FfiConverterTypeZcashBranchId.lift(buf)
}

public func FfiConverterTypeZcashBranchId_lower(_ value: ZcashBranchId) -> RustBuffer {
    return FfiConverterTypeZcashBranchId.lower(value)
}

extension ZcashBranchId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashChildIndex {
    case nonHardened(v: UInt32)

    case hardened(v: UInt32)
}

public struct FfiConverterTypeZcashChildIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashChildIndex

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashChildIndex {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .nonHardened(
                v: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return try .hardened(
                v: FfiConverterUInt32.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashChildIndex, into buf: inout [UInt8]) {
        switch value {
        case let .nonHardened(v):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v, into: &buf)

        case let .hardened(v):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashChildIndex_lift(_ buf: RustBuffer) throws -> ZcashChildIndex {
    return try FfiConverterTypeZcashChildIndex.lift(buf)
}

public func FfiConverterTypeZcashChildIndex_lower(_ value: ZcashChildIndex) -> RustBuffer {
    return FfiConverterTypeZcashChildIndex.lower(value)
}

extension ZcashChildIndex: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashConsensusParameters {
    case mainNetwork

    case testNetwork
}

public struct FfiConverterTypeZcashConsensusParameters: FfiConverterRustBuffer {
    typealias SwiftType = ZcashConsensusParameters

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashConsensusParameters {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainNetwork

        case 2: return .testNetwork

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashConsensusParameters, into buf: inout [UInt8]) {
        switch value {
        case .mainNetwork:
            writeInt(&buf, Int32(1))

        case .testNetwork:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashConsensusParameters_lift(_ buf: RustBuffer) throws -> ZcashConsensusParameters {
    return try FfiConverterTypeZcashConsensusParameters.lift(buf)
}

public func FfiConverterTypeZcashConsensusParameters_lower(_ value: ZcashConsensusParameters) -> RustBuffer {
    return FfiConverterTypeZcashConsensusParameters.lower(value)
}

extension ZcashConsensusParameters: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashDustAction {
    case reject

    case allowDustChange

    case addDustToFee
}

public struct FfiConverterTypeZcashDustAction: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDustAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashDustAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .reject

        case 2: return .allowDustChange

        case 3: return .addDustToFee

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashDustAction, into buf: inout [UInt8]) {
        switch value {
        case .reject:
            writeInt(&buf, Int32(1))

        case .allowDustChange:
            writeInt(&buf, Int32(2))

        case .addDustToFee:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeZcashDustAction_lift(_ buf: RustBuffer) throws -> ZcashDustAction {
    return try FfiConverterTypeZcashDustAction.lift(buf)
}

public func FfiConverterTypeZcashDustAction_lower(_ value: ZcashDustAction) -> RustBuffer {
    return FfiConverterTypeZcashDustAction.lower(value)
}

extension ZcashDustAction: Equatable, Hashable {}

public enum ZcashError {
    // Simple error enums only carry a message
    case HdWalletError(message: String)

    // Simple error enums only carry a message
    case DecodingError(message: String)

    // Simple error enums only carry a message
    case DerivationError(message: String)

    // Simple error enums only carry a message
    case InvalidAsk(message: String)

    // Simple error enums only carry a message
    case InvalidNsk(message: String)

    // Simple error enums only carry a message
    case Message(message: String)

    // Simple error enums only carry a message
    case ArrayLengthMismatch(message: String)

    // Simple error enums only carry a message
    case ValueOutOfRange(message: String)

    // Simple error enums only carry a message
    case Secp256k1Error(message: String)

    // Simple error enums only carry a message
    case Bech32DecodeError(message: String)

    // Simple error enums only carry a message
    case Bs58Error(message: String)

    // Simple error enums only carry a message
    case BuilderError(message: String)

    // Simple error enums only carry a message
    case TransparentBuilderError(message: String)

    // Simple error enums only carry a message
    case SaplingBuilderError(message: String)

    // Simple error enums only carry a message
    case OrchardBuilderError(message: String)

    // Simple error enums only carry a message
    case OrchardBuilderSpendError(message: String)

    // Simple error enums only carry a message
    case OrchardBuilderOutputError(message: String)

    // Simple error enums only carry a message
    case InsufficientFundsError(message: String)

    // Simple error enums only carry a message
    case ChangeRequiredError(message: String)

    // Simple error enums only carry a message
    case BalanceError(message: String)

    // Simple error enums only carry a message
    case IoError(message: String)

    // Simple error enums only carry a message
    case Unknown(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeZcashError.lift(error)
    }
}

public struct FfiConverterTypeZcashError: FfiConverterRustBuffer {
    typealias SwiftType = ZcashError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .HdWalletError(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .DecodingError(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .DerivationError(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InvalidAsk(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvalidNsk(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .Message(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .ArrayLengthMismatch(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .ValueOutOfRange(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .Secp256k1Error(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .Bech32DecodeError(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .Bs58Error(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .BuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .TransparentBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .SaplingBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .OrchardBuilderError(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .OrchardBuilderSpendError(
                message: FfiConverterString.read(from: &buf)
            )

        case 17: return try .OrchardBuilderOutputError(
                message: FfiConverterString.read(from: &buf)
            )

        case 18: return try .InsufficientFundsError(
                message: FfiConverterString.read(from: &buf)
            )

        case 19: return try .ChangeRequiredError(
                message: FfiConverterString.read(from: &buf)
            )

        case 20: return try .BalanceError(
                message: FfiConverterString.read(from: &buf)
            )

        case 21: return try .IoError(
                message: FfiConverterString.read(from: &buf)
            )

        case 22: return try .Unknown(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashError, into buf: inout [UInt8]) {
        switch value {
        case .HdWalletError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .DecodingError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .DerivationError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .InvalidAsk(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvalidNsk(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .Message(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .ArrayLengthMismatch(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .ValueOutOfRange(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .Secp256k1Error(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .Bech32DecodeError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .Bs58Error(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .BuilderError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        case .TransparentBuilderError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(13))
        case .SaplingBuilderError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(14))
        case .OrchardBuilderError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(15))
        case .OrchardBuilderSpendError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(16))
        case .OrchardBuilderOutputError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(17))
        case .InsufficientFundsError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(18))
        case .ChangeRequiredError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(19))
        case .BalanceError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(20))
        case .IoError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(21))
        case .Unknown(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(22))
        }
    }
}

extension ZcashError: Equatable, Hashable {}

extension ZcashError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashFeeRules {
    case fixedStandard

    case fixedNonStandard(amount: UInt64)

    case zip317Standard

    case zip317NonStandard(marginalFee: UInt64, graceActions: UInt64, p2pkhStandardInputSize: UInt64, p2pkhStandardOutputSize: UInt64)
}

public struct FfiConverterTypeZcashFeeRules: FfiConverterRustBuffer {
    typealias SwiftType = ZcashFeeRules

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashFeeRules {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .fixedStandard

        case 2: return try .fixedNonStandard(
                amount: FfiConverterUInt64.read(from: &buf)
            )

        case 3: return .zip317Standard

        case 4: return try .zip317NonStandard(
                marginalFee: FfiConverterUInt64.read(from: &buf),
                graceActions: FfiConverterUInt64.read(from: &buf),
                p2pkhStandardInputSize: FfiConverterUInt64.read(from: &buf),
                p2pkhStandardOutputSize: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashFeeRules, into buf: inout [UInt8]) {
        switch value {
        case .fixedStandard:
            writeInt(&buf, Int32(1))

        case let .fixedNonStandard(amount):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(amount, into: &buf)

        case .zip317Standard:
            writeInt(&buf, Int32(3))

        case let .zip317NonStandard(marginalFee, graceActions, p2pkhStandardInputSize, p2pkhStandardOutputSize):
            writeInt(&buf, Int32(4))
            FfiConverterUInt64.write(marginalFee, into: &buf)
            FfiConverterUInt64.write(graceActions, into: &buf)
            FfiConverterUInt64.write(p2pkhStandardInputSize, into: &buf)
            FfiConverterUInt64.write(p2pkhStandardOutputSize, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashFeeRules_lift(_ buf: RustBuffer) throws -> ZcashFeeRules {
    return try FfiConverterTypeZcashFeeRules.lift(buf)
}

public func FfiConverterTypeZcashFeeRules_lower(_ value: ZcashFeeRules) -> RustBuffer {
    return FfiConverterTypeZcashFeeRules.lower(value)
}

extension ZcashFeeRules: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashKeySeed {
    case s128

    case s256

    case s512
}

public struct FfiConverterTypeZcashKeySeed: FfiConverterRustBuffer {
    typealias SwiftType = ZcashKeySeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeySeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .s128

        case 2: return .s256

        case 3: return .s512

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashKeySeed, into buf: inout [UInt8]) {
        switch value {
        case .s128:
            writeInt(&buf, Int32(1))

        case .s256:
            writeInt(&buf, Int32(2))

        case .s512:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeZcashKeySeed_lift(_ buf: RustBuffer) throws -> ZcashKeySeed {
    return try FfiConverterTypeZcashKeySeed.lift(buf)
}

public func FfiConverterTypeZcashKeySeed_lower(_ value: ZcashKeySeed) -> RustBuffer {
    return FfiConverterTypeZcashKeySeed.lower(value)
}

extension ZcashKeySeed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashKeysEra {
    case orchard
}

public struct FfiConverterTypeZcashKeysEra: FfiConverterRustBuffer {
    typealias SwiftType = ZcashKeysEra

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashKeysEra {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .orchard

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashKeysEra, into buf: inout [UInt8]) {
        switch value {
        case .orchard:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeZcashKeysEra_lift(_ buf: RustBuffer) throws -> ZcashKeysEra {
    return try FfiConverterTypeZcashKeysEra.lift(buf)
}

public func FfiConverterTypeZcashKeysEra_lower(_ value: ZcashKeysEra) -> RustBuffer {
    return FfiConverterTypeZcashKeysEra.lower(value)
}

extension ZcashKeysEra: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashOrchardScope {
    case external

    case `internal`
}

public struct FfiConverterTypeZcashOrchardScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardScope

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOrchardScope {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .external

        case 2: return .internal

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashOrchardScope, into buf: inout [UInt8]) {
        switch value {
        case .external:
            writeInt(&buf, Int32(1))

        case .internal:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashOrchardScope_lift(_ buf: RustBuffer) throws -> ZcashOrchardScope {
    return try FfiConverterTypeZcashOrchardScope.lift(buf)
}

public func FfiConverterTypeZcashOrchardScope_lower(_ value: ZcashOrchardScope) -> RustBuffer {
    return FfiConverterTypeZcashOrchardScope.lower(value)
}

extension ZcashOrchardScope: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashOvkPolicy {
    case sender

    case custom(bytes: [UInt8])

    case discard
}

public struct FfiConverterTypeZcashOvkPolicy: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOvkPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashOvkPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sender

        case 2: return try .custom(
                bytes: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 3: return .discard

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashOvkPolicy, into buf: inout [UInt8]) {
        switch value {
        case .sender:
            writeInt(&buf, Int32(1))

        case let .custom(bytes):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(bytes, into: &buf)

        case .discard:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeZcashOvkPolicy_lift(_ buf: RustBuffer) throws -> ZcashOvkPolicy {
    return try FfiConverterTypeZcashOvkPolicy.lift(buf)
}

public func FfiConverterTypeZcashOvkPolicy_lower(_ value: ZcashOvkPolicy) -> RustBuffer {
    return FfiConverterTypeZcashOvkPolicy.lower(value)
}

extension ZcashOvkPolicy: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashRseed {
    case beforeZip212(frData: [UInt8])

    case afterZip212(data: [UInt8])
}

public struct FfiConverterTypeZcashRseed: FfiConverterRustBuffer {
    typealias SwiftType = ZcashRseed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashRseed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .beforeZip212(
                frData: FfiConverterSequenceUInt8.read(from: &buf)
            )

        case 2: return try .afterZip212(
                data: FfiConverterSequenceUInt8.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashRseed, into buf: inout [UInt8]) {
        switch value {
        case let .beforeZip212(frData):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(frData, into: &buf)

        case let .afterZip212(data):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(data, into: &buf)
        }
    }
}

public func FfiConverterTypeZcashRseed_lift(_ buf: RustBuffer) throws -> ZcashRseed {
    return try FfiConverterTypeZcashRseed.lift(buf)
}

public func FfiConverterTypeZcashRseed_lower(_ value: ZcashRseed) -> RustBuffer {
    return FfiConverterTypeZcashRseed.lower(value)
}

extension ZcashRseed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashScanPriority {
    case ignored

    case scanned

    case historic

    case openAdjacent

    case foundNote

    case chainTip

    case verify
}

public struct FfiConverterTypeZcashScanPriority: FfiConverterRustBuffer {
    typealias SwiftType = ZcashScanPriority

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScanPriority {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .ignored

        case 2: return .scanned

        case 3: return .historic

        case 4: return .openAdjacent

        case 5: return .foundNote

        case 6: return .chainTip

        case 7: return .verify

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashScanPriority, into buf: inout [UInt8]) {
        switch value {
        case .ignored:
            writeInt(&buf, Int32(1))

        case .scanned:
            writeInt(&buf, Int32(2))

        case .historic:
            writeInt(&buf, Int32(3))

        case .openAdjacent:
            writeInt(&buf, Int32(4))

        case .foundNote:
            writeInt(&buf, Int32(5))

        case .chainTip:
            writeInt(&buf, Int32(6))

        case .verify:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeZcashScanPriority_lift(_ buf: RustBuffer) throws -> ZcashScanPriority {
    return try FfiConverterTypeZcashScanPriority.lift(buf)
}

public func FfiConverterTypeZcashScanPriority_lower(_ value: ZcashScanPriority) -> RustBuffer {
    return FfiConverterTypeZcashScanPriority.lower(value)
}

extension ZcashScanPriority: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashScope {
    case external

    case `internal`
}

public struct FfiConverterTypeZcashScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashScope

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashScope {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .external

        case 2: return .internal

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashScope, into buf: inout [UInt8]) {
        switch value {
        case .external:
            writeInt(&buf, Int32(1))

        case .internal:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeZcashScope_lift(_ buf: RustBuffer) throws -> ZcashScope {
    return try FfiConverterTypeZcashScope.lift(buf)
}

public func FfiConverterTypeZcashScope_lower(_ value: ZcashScope) -> RustBuffer {
    return FfiConverterTypeZcashScope.lower(value)
}

extension ZcashScope: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashShieldedProtocol {
    case sapling
}

public struct FfiConverterTypeZcashShieldedProtocol: FfiConverterRustBuffer {
    typealias SwiftType = ZcashShieldedProtocol

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashShieldedProtocol {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .sapling

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashShieldedProtocol, into buf: inout [UInt8]) {
        switch value {
        case .sapling:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeZcashShieldedProtocol_lift(_ buf: RustBuffer) throws -> ZcashShieldedProtocol {
    return try FfiConverterTypeZcashShieldedProtocol.lift(buf)
}

public func FfiConverterTypeZcashShieldedProtocol_lower(_ value: ZcashShieldedProtocol) -> RustBuffer {
    return FfiConverterTypeZcashShieldedProtocol.lower(value)
}

extension ZcashShieldedProtocol: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZcashTxVersionSelection {
    case sprout(v: UInt32)

    case overwinter

    case sapling

    case zip225
}

public struct FfiConverterTypeZcashTxVersionSelection: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTxVersionSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashTxVersionSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .sprout(
                v: FfiConverterUInt32.read(from: &buf)
            )

        case 2: return .overwinter

        case 3: return .sapling

        case 4: return .zip225

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashTxVersionSelection, into buf: inout [UInt8]) {
        switch value {
        case let .sprout(v):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v, into: &buf)

        case .overwinter:
            writeInt(&buf, Int32(2))

        case .sapling:
            writeInt(&buf, Int32(3))

        case .zip225:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeZcashTxVersionSelection_lift(_ buf: RustBuffer) throws -> ZcashTxVersionSelection {
    return try FfiConverterTypeZcashTxVersionSelection.lift(buf)
}

public func FfiConverterTypeZcashTxVersionSelection_lower(_ value: ZcashTxVersionSelection) -> RustBuffer {
    return FfiConverterTypeZcashTxVersionSelection.lower(value)
}

extension ZcashTxVersionSelection: Equatable, Hashable {}

public enum ZcashWalletMigrationError {
    case SeedRequired
    case CorruptedData(v: String)
    case DbError(v: String)
    case BalanceError(v: String)
    case CommitmentTreeError(v: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeZcashWalletMigrationError.lift(error)
    }
}

public struct FfiConverterTypeZcashWalletMigrationError: FfiConverterRustBuffer {
    typealias SwiftType = ZcashWalletMigrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashWalletMigrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .SeedRequired
        case 2: return try .CorruptedData(
                v: FfiConverterString.read(from: &buf)
            )
        case 3: return try .DbError(
                v: FfiConverterString.read(from: &buf)
            )
        case 4: return try .BalanceError(
                v: FfiConverterString.read(from: &buf)
            )
        case 5: return try .CommitmentTreeError(
                v: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashWalletMigrationError, into buf: inout [UInt8]) {
        switch value {
        case .SeedRequired:
            writeInt(&buf, Int32(1))

        case let .CorruptedData(v):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v, into: &buf)

        case let .DbError(v):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v, into: &buf)

        case let .BalanceError(v):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v, into: &buf)

        case let .CommitmentTreeError(v):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v, into: &buf)
        }
    }
}

extension ZcashWalletMigrationError: Equatable, Hashable {}

extension ZcashWalletMigrationError: Error {}

public enum ZcashZip321Error {
    case TooManyPayments(v: UInt32)
    case TransparentMemo(v: UInt32)
    case RecipientMissing(v: UInt32)
    case ParseError(v: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeZcashZip321Error.lift(error)
    }
}

public struct FfiConverterTypeZcashZip321Error: FfiConverterRustBuffer {
    typealias SwiftType = ZcashZip321Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashZip321Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .TooManyPayments(
                v: FfiConverterUInt32.read(from: &buf)
            )
        case 2: return try .TransparentMemo(
                v: FfiConverterUInt32.read(from: &buf)
            )
        case 3: return try .RecipientMissing(
                v: FfiConverterUInt32.read(from: &buf)
            )
        case 4: return try .ParseError(
                v: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashZip321Error, into buf: inout [UInt8]) {
        switch value {
        case let .TooManyPayments(v):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v, into: &buf)

        case let .TransparentMemo(v):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v, into: &buf)

        case let .RecipientMissing(v):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v, into: &buf)

        case let .ParseError(v):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v, into: &buf)
        }
    }
}

extension ZcashZip321Error: Equatable, Hashable {}

extension ZcashZip321Error: Error {}

private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashAccountPubKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashAccountPubKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashAccountPubKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashAccountPubKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashAmount: FfiConverterRustBuffer {
    typealias SwiftType = ZcashAmount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashBlockHeight: FfiConverterRustBuffer {
    typealias SwiftType = ZcashBlockHeight?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashBlockHeight.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashBlockHeight.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashBlockMeta: FfiConverterRustBuffer {
    typealias SwiftType = ZcashBlockMeta?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashBlockMeta.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashBlockMeta.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifiableFullViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifiableFullViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifiableFullViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifiableFullViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashMemoBytes: FfiConverterRustBuffer {
    typealias SwiftType = ZcashMemoBytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashMemoBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashMemoBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardDiversifierIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardDiversifierIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardDiversifierIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardDiversifierIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardFullViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardFullViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardFullViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardFullViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardOutgoingViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOutgoingViewingKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOutgoingViewingKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOutgoingViewingKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashPaymentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashPaymentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashPaymentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashPaymentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashRatio: FfiConverterRustBuffer {
    typealias SwiftType = ZcashRatio?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashRatio.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashRatio.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashSaplingBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashSaplingBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashSaplingBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashSaplingBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashSaplingMerklePath: FfiConverterRustBuffer {
    typealias SwiftType = ZcashSaplingMerklePath?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashSaplingMerklePath.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashSaplingMerklePath.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashTransparentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTransparentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashTransparentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashTransparentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashTransparentBundle: FfiConverterRustBuffer {
    typealias SwiftType = ZcashTransparentBundle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashTransparentBundle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashTransparentBundle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashUnifiedAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashUnifiedAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashUnifiedAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashUnifiedAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashWalletSummary: FfiConverterRustBuffer {
    typealias SwiftType = ZcashWalletSummary?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashWalletSummary.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashWalletSummary.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashAccountId: FfiConverterRustBuffer {
    typealias SwiftType = ZcashAccountId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashAccountId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashAccountId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifierIndexAndPaymentAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashDiversifierIndexAndScope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashDiversifierIndexAndScope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashDiversifierIndexAndScope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer {
    typealias SwiftType = ZcashUnifiedAddressAndDiversifierIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeZcashOrchardScope: FfiConverterRustBuffer {
    typealias SwiftType = ZcashOrchardScope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZcashOrchardScope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZcashOrchardScope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashBlockHeight: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashBlockHeight]

    public static func write(_ value: [ZcashBlockHeight], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashBlockHeight.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashBlockHeight] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashBlockHeight]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashBlockHeight.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashBlockMeta: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashBlockMeta]

    public static func write(_ value: [ZcashBlockMeta], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashBlockMeta.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashBlockMeta] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashBlockMeta]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashBlockMeta.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashCommitmentTreeRoot: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashCommitmentTreeRoot]

    public static func write(_ value: [ZcashCommitmentTreeRoot], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashCommitmentTreeRoot.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashCommitmentTreeRoot] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashCommitmentTreeRoot]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashCommitmentTreeRoot.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardAction: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardAction]

    public static func write(_ value: [ZcashOrchardAction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardAction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardAction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardAction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardAction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardIncomingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardIncomingViewingKey]

    public static func write(_ value: [ZcashOrchardIncomingViewingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardIncomingViewingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardIncomingViewingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardIncomingViewingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardMerkleHash: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardMerkleHash]

    public static func write(_ value: [ZcashOrchardMerkleHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardMerkleHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardMerkleHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardMerkleHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardMerkleHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardOutgoingViewingKey]

    public static func write(_ value: [ZcashOrchardOutgoingViewingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardOutgoingViewingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardOutgoingViewingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardOutgoingViewingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardSpendingKey: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardSpendingKey]

    public static func write(_ value: [ZcashOrchardSpendingKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardSpendingKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardSpendingKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardSpendingKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardSpendingKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOutPoint]

    public static func write(_ value: [ZcashOutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOutPoint.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashSaplingOutputDescription: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashSaplingOutputDescription]

    public static func write(_ value: [ZcashSaplingOutputDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashSaplingOutputDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashSaplingOutputDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashSaplingOutputDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashSaplingOutputDescription.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashSaplingSpendDescription: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashSaplingSpendDescription]

    public static func write(_ value: [ZcashSaplingSpendDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashSaplingSpendDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashSaplingSpendDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashSaplingSpendDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashSaplingSpendDescription.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashScanRange: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashScanRange]

    public static func write(_ value: [ZcashScanRange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashScanRange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashScanRange] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashScanRange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashScanRange.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashTxIn: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashTxIn]

    public static func write(_ value: [ZcashTxIn], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashTxIn.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashTxIn] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashTxIn]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashTxIn.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashTxOut: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashTxOut]

    public static func write(_ value: [ZcashTxOut], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashTxOut.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashTxOut] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashTxOut]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashTxOut.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashWalletTransparentOutput: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashWalletTransparentOutput]

    public static func write(_ value: [ZcashWalletTransparentOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashWalletTransparentOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashWalletTransparentOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashWalletTransparentOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashWalletTransparentOutput.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashAuthPath: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashAuthPath]

    public static func write(_ value: [ZcashAuthPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashAuthPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashAuthPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashAuthPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashAuthPath.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardDecryptOutputForIncomingKeys]

    public static func write(_ value: [ZcashOrchardDecryptOutputForIncomingKeys], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardDecryptOutputForIncomingKeys] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardDecryptOutputForIncomingKeys]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashOrchardDecryptOutputForOutgoingKeys]

    public static func write(_ value: [ZcashOrchardDecryptOutputForOutgoingKeys], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashOrchardDecryptOutputForOutgoingKeys] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashOrchardDecryptOutputForOutgoingKeys]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashPayment: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashPayment]

    public static func write(_ value: [ZcashPayment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashPayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashPayment] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashPayment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashPayment.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashPaymentParam: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashPaymentParam]

    public static func write(_ value: [ZcashPaymentParam], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashPaymentParam.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashPaymentParam] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashPaymentParam]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashPaymentParam.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeZcashChildIndex: FfiConverterRustBuffer {
    typealias SwiftType = [ZcashChildIndex]

    public static func write(_ value: [ZcashChildIndex], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeZcashChildIndex.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ZcashChildIndex] {
        let len: Int32 = try readInt(&buf)
        var seq = [ZcashChildIndex]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeZcashChildIndex.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringTypeZcashAccountBalance: FfiConverterRustBuffer {
    public static func write(_ value: [String: ZcashAccountBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeZcashAccountBalance.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ZcashAccountBalance] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ZcashAccountBalance]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeZcashAccountBalance.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeZcashAddressMetadata: FfiConverterRustBuffer {
    public static func write(_ value: [String: ZcashAddressMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeZcashAddressMetadata.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ZcashAddressMetadata] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ZcashAddressMetadata]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeZcashAddressMetadata.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func decodeExtendedFullViewingKey(hrp: String, s: String) throws -> ZcashExtendedFullViewingKey {
    return try FfiConverterTypeZcashExtendedFullViewingKey.lift(
        rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_func_decode_extended_full_viewing_key(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodeExtendedSpendingKey(hrp: String, s: String) throws -> ZcashExtendedSpendingKey {
    return try FfiConverterTypeZcashExtendedSpendingKey.lift(
        rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_func_decode_extended_spending_key(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodePaymentAddress(hrp: String, s: String) throws -> ZcashPaymentAddress {
    return try FfiConverterTypeZcashPaymentAddress.lift(
        rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_func_decode_payment_address(
                FfiConverterString.lower(hrp),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func decodeTransparentAddress(pubkeyVersion: [UInt8], scriptVersion: [UInt8], s: String) throws -> ZcashTransparentAddress {
    return try FfiConverterTypeZcashTransparentAddress.lift(
        rustCallWithError(FfiConverterTypeZcashError.lift) {
            uniffi_uniffi_zcash_fn_func_decode_transparent_address(
                FfiConverterSequenceUInt8.lower(pubkeyVersion),
                FfiConverterSequenceUInt8.lower(scriptVersion),
                FfiConverterString.lower(s), $0
            )
        }
    )
}

public func encodeExtendedFullViewingKey(hrp: String, extfvk: ZcashExtendedFullViewingKey) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_extended_full_viewing_key(
                FfiConverterString.lower(hrp),
                FfiConverterTypeZcashExtendedFullViewingKey.lower(extfvk), $0
            )
        }
    )
}

public func encodeExtendedSpendingKey(hrp: String, extsk: ZcashExtendedSpendingKey) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_extended_spending_key(
                FfiConverterString.lower(hrp),
                FfiConverterTypeZcashExtendedSpendingKey.lower(extsk), $0
            )
        }
    )
}

public func encodePaymentAddress(hrp: String, addr: ZcashPaymentAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_payment_address(
                FfiConverterString.lower(hrp),
                FfiConverterTypeZcashPaymentAddress.lower(addr), $0
            )
        }
    )
}

public func encodePaymentAddressP(params: ZcashConsensusParameters, addr: ZcashPaymentAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_payment_address_p(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterTypeZcashPaymentAddress.lower(addr), $0
            )
        }
    )
}

public func encodeTransparentAddress(pubkeyVersion: [UInt8], scriptVersion: [UInt8], addr: ZcashTransparentAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_transparent_address(
                FfiConverterSequenceUInt8.lower(pubkeyVersion),
                FfiConverterSequenceUInt8.lower(scriptVersion),
                FfiConverterTypeZcashTransparentAddress.lower(addr), $0
            )
        }
    )
}

public func encodeTransparentAddressP(params: ZcashConsensusParameters, addr: ZcashTransparentAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_uniffi_zcash_fn_func_encode_transparent_address_p(
                FfiConverterTypeZcashConsensusParameters.lower(params),
                FfiConverterTypeZcashTransparentAddress.lower(addr), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 23
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_uniffi_zcash_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_decode_extended_full_viewing_key() != 43 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_decode_extended_spending_key() != 11044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_decode_payment_address() != 6408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_decode_transparent_address() != 14315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_extended_full_viewing_key() != 9529 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_extended_spending_key() != 31408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_payment_address() != 18682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_payment_address_p() != 8373 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_transparent_address() != 51536 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_func_encode_transparent_address_p() != 44460 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_secpsecretkey_serialize_secret() != 54704 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_string() != 28106 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u32() != 38141 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u32_array() != 20821 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u64() != 37018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u64_array() != 34269 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u8_array() != 33558 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountbalance_sapling_spendable_value() != 62416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountbalance_total() != 46654 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_derive_external_secret_key() != 23016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_derive_internal_secret_key() != 47416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_to_account_pubkey() != 30998 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_to_bytes() != 49891 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_derive_external_ivk() != 35623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_derive_internal_ivk() != 47007 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_external_ovk() != 32909 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_internal_ovk() != 7272 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_ovks_for_shielding() != 53259 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_serialize() != 61612 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaddressmetadata_account() != 6738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashaddressmetadata_diversifier_index() != 21690 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashamount_value() != 59960 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashanchor_to_bytes() != 60719 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashbackendscan_scan_cached_blocks() != 43893 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashbalance_total() != 19876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashblockheight_value() != 22213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashblockmeta_block_file_path() != 47636 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashchain_init_blockmeta_db() != 26933 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashcommitmenttree_append() != 9731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashcommitmenttreeroot_root_hash() != 61519 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashcommitmenttreeroot_subtree_end_height() != 42288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_address() != 56872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_change_address() != 3292 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_decrypt_diversifier() != 17128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_default_address() != 26955 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_diversified_address() != 34240 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_diversified_change_address() != 27945 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_find_address() != 8183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_fvk() != 41453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_bytes() != 61280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_ivk() != 64505 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_nk() != 48754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_ovk() != 62774 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifier_to_bytes() != 30398 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_increment() != 11312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_to_bytes() != 63159 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_to_u32() != 44617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdustoutputpolicy_action() != 44513 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashdustoutputpolicy_dust_threshold() != 7721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexpandedspendingkey_proof_generation_key() != 61644 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexpandedspendingkey_to_bytes() != 43168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_address() != 8014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_default_address() != 29996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_derive_child() != 47098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_derive_internal() != 38309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_encode() != 29123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_find_address() != 34143 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_to_bytes() != 18841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_to_diversifiable_full_viewing_key() != 50451 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedprivkey_derive_private_key() != 12389 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedprivkey_to_bytes() != 5856 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_default_address() != 22729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_derive_child() != 41513 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_derive_internal() != 55203 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_encode() != 44371 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_to_bytes() != 17343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_to_diversifiable_full_viewing_key() != 62056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexternalivk_default_address() != 11498 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexternalivk_derive_address() != 27436 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexternalivk_to_bytes() != 51247 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashexternalovk_as_bytes() != 36375 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashextractednotecommitment_to_bytes() != 17657 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfixedfeerule_fixed_fee() != 14897 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_find_block() != 39154 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_get_max_cached_height() != 51557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_write_block_metadata() != 23343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_ovk() != 17756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_to_bytes() != 36808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_vk() != 891 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashincrementalwitness_append() != 6023 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashincrementalwitness_path() != 58534 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashinternalivk_default_address() != 38026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashinternalivk_to_bytes() != 20243 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashinternalovk_as_bytes() != 31389 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashjubjubfr_to_bytes() != 31411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashkeyindex_is_valid() != 51631 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashkeyindex_normalize_index() != 54488 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashkeyindex_raw_index() != 11448 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashmemobytes_data() != 58446 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashnonnegativeamount_value() != 16814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashnullifierderivingkey_to_bytes() != 55602 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaction_cmx() != 8135 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaction_cv_net() != 40584 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaction_encrypted_note() != 30980 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaction_nullifier() != 52746 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaddress_diversifier() != 47461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardaddress_to_raw_address_bytes() != 30894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_actions() != 28699 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_anchor() != 54544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_decrypt_output_with_key() != 47785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_decrypt_output_with_keys() != 25404 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_flags() != 36198 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_recover_output_with_ovk() != 5638 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_recover_outputs_with_ovks() != 3017 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_value_balance() != 10325 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_verify_proof() != 50799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorcharddiversifier_to_bytes() != 40646 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorcharddiversifierindex_to_bytes() != 23735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardflags_outputs_enabled() != 21630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardflags_spends_enabled() != 20196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardflags_to_byte() != 40819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_address() != 37932 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_address_at() != 13313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_scope_for_address() != 12826 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_bytes() != 4066 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_ivk() != 55622 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_ovk() != 27275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_address() != 4673 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_address_at() != 56154 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_diversifier_index() != 41453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_to_bytes() != 7328 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardmerklehash_to_bytes() != 27276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardmerklepath_root() != 2184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnote_commitment() != 5572 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnote_recipient() != 23794 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnote_value() != 62317 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnotecommitment_to_extracted_note_commitment() != 43802 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnotevalue_value() != 18931 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardnullifier_to_bytes() != 19883 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardoutgoingviewingkey_to_bytes() != 40703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardrandomseed_to_bytes() != 60561 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardspendingkey_to_bytes() != 2204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardspendingkey_to_fvk() != 31948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_add_recipient() != 38963 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_add_spend() != 25684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_build() != 29859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashorchardvaluecommitment_to_bytes() != 60988 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashoutgoingviewingkey_to_bytes() != 29445 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_create_note() != 16613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_diversifier() != 4558 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_encode() != 47540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_pk_d() != 3756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_to_bytes() != 62344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashproofgenerationkey_to_viewing_key() != 13370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashratio_denominator() != 49055 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashratio_numerator() != 13950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashrecipientaddress_encode() != 6086 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_shielded_outputs() != 2847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_shielded_spends() != 25103 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_value_balance() != 20257 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingextractednotecommitment_to_bytes() != 48009 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingivk_to_payment_address() != 57356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingivk_to_repr() != 3274 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingmerklepath_auth_path() != 7582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingmerklepath_position() != 42629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingmetadata_output_index() != 10823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingmetadata_spend_index() != 18537 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingnote_cmu() != 46875 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingnote_value() != 41811 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingnotevalue_inner() != 39749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingnullifier_to_bytes() != 32283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingoutputdescription_cmu() != 37606 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingoutputdescription_cv() != 19907 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingpublickey_to_bytes() != 53973 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_anchor() != 57018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_cv() != 36817 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_nullifier() != 49913 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_rk() != 56943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashsaplingvaluecommitment_to_bytes() != 15898 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashscanrange_block_range() != 20621 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashscanrange_is_empty() != 29099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashscanrange_len() != 1811 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashscanrange_priority() != 8375 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashscript_to_bytes() != 23762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_consensus_branch_id() != 18318 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_expiry_height() != 11948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_lock_time() != 12936 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_orchard_bundle() != 43336 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_sapling_bundle() != 61494 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_to_bytes() != 45553 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_transparent_bundle() != 35192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_txid() != 1587 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransaction_version() != 3232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_sapling_output() != 58509 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_sapling_spend() != 28498 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_transparent_input() != 33123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_transparent_output() != 53451 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_build() != 60029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionrequest_payments() != 42686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransactionrequest_to_uri() != 51173 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_encode() != 21027 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_is_public_key() != 55021 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_is_script() != 29922 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_script() != 5353 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_to_bytes() != 58716 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_is_coinbase() != 20027 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_vin() != 8937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_vout() != 31247 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxid_to_bytes() != 38587 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxin_to_bytes() != 4105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxout_recipient_address() != 35192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxout_script_pubkey() != 3662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxout_to_bytes() != 29744 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxout_value() != 35166 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_orchard() != 24972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_overwinter() != 14188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_sapling() != 58818 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_sprout() != 21741 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_header() != 29274 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_selection() != 13597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_to_bytes() != 61209 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashtxversion_version_group_id() != 6711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_encode() != 43943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_orchard() != 55957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_sapling() != 15283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_transparent() != 2573 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_address() != 14263 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_default_address() != 47526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_encode() != 52042 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_find_address() != 15089 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_orchard() != 42648 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_sapling() != 39731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_transparent() != 14275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_orchard() != 47836 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_sapling() != 18405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_to_bytes() != 24111 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_to_unified_full_viewing_key() != 18827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_transparent() != 39270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashviewingkey_ivk() != 47894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashviewingkey_to_payment_address() != 36128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallet_init_wallet_db() != 11523 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_account_for_ufvk() != 16427 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_current_address() != 6512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_min_unspent_height() != 44311 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_transparent_receivers() != 44783 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_unspent_transparent_outputs() != 63544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_wallet_summary() != 7833 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_put_received_transparent_utxo() != 7966 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_put_sapling_subtree_roots() != 59990 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_store_decrypted_tx() != 39162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_suggest_scan_ranges() != 13781 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_truncate_to_height() != 41324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletdb_update_chain_tip() != 53618 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_account_balances() != 46767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_chain_tip_height() != 16303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_fully_scanned_height() != 13225 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_is_synced() != 48420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_scan_progress() != 22522 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_height() != 11140 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_outpoint() != 36462 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_recipient_address() != 59737 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_txout() != 2768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_value() != 35662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_method_zcashzip317feerule_marginal_fee() != 8182 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_secpsecretkey_new() != 64573 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_testsupport_from_csv_file() != 33828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaccountbalance_zero() != 33487 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_bytes() != 26651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_extended_privkey() != 37304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_seed() != 64225 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaccountpubkey_new() != 9170 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashaddressmetadata_new() != 57325 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashamount_new() != 42128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashamount_zero() != 24788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashanchor_from_bytes() != 1309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashbalance_zero() != 29923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashblockhash_from_slice() != 58322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashblockheight_new() != 45578 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashcommitmenttree_empty() != 623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashcommitmenttreeroot_from_parts() != 45967 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdiversifiablefullviewingkey_from_bytes() != 13134 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdiversifier_new() != 59084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_from_u32() != 9534 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_from_u64() != 34210 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_new() != 56308 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashdustoutputpolicy_new() != 22663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashexpandedspendingkey_from_bytes() != 47896 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashexpandedspendingkey_from_spending_key() != 45434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedfullviewingkey_decode() != 31388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedfullviewingkey_from_bytes() != 59768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_from_bytes() != 60356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_random() != 14451 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_random_with_seed_size() != 59830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_with_seed() != 4742 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_decode() != 45865 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_from_bytes() != 1088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_from_path() != 54996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_master() != 52937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashexternalivk_from_bytes() != 41557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashextractednotecommitment_from_bytes() != 36721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfixedfeerule_non_standard() != 43642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfixedfeerule_standard() != 26951 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfixedsingleoutputchangestrategy_new() != 34109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfsblockdb_for_path() != 56557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfullviewingkey_from_bytes() != 31151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashfullviewingkey_from_expanded_spending_key() != 15606 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashincrementalwitness_from_tree() != 24062 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashinternalivk_from_bytes() != 14714 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashjubjubfr_from_bytes() != 58321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_from_index() != 15946 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_from_u32() != 10447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_hardened_from_normalize_index() != 38879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_from_bytes() != 25592 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_new() != 57963 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_with_default_location() != 59894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashmaingreedyinputselector_new() != 791 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashmemobytes_empty() != 65126 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashmemobytes_new() != 37981 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_from_nonnegative_i64() != 8268 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_from_u64() != 56516 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_zero() != 8841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashnoteid_new() != 38776 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashnullifierderivingkey_from_bytes() != 21854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardaddress_from_raw_address_bytes() != 63827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifier_from_bytes() != 34408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_bytes() != 25514 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_u32() != 43709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_u64() != 2654 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardflags_from_byte() != 60462 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardflags_from_parts() != 29886 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardfullviewingkey_from_bytes() != 36989 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardincomingviewingkey_from_bytes() != 13118 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklehash_from_bytes() != 12323 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklehash_from_cmx() != 16324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklepath_from_parts() != 28767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardnote_from_parts() != 18196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardnotevalue_from_raw() != 19994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardnullifier_from_bytes() != 34345 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardoutgoingviewingkey_from_bytes() != 22911 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardrandomseed_from_bytes() != 24509 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardspendingkey_from_bytes() != 63051 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardspendingkey_from_zip32_seed() != 9945 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashorchardtransactionbuilder_new() != 33 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashoutpoint_new() != 20595 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashoutgoingviewingkey_from_bytes() != 48420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashpaymentaddress_decode() != 17087 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashpaymentaddress_from_bytes() != 42926 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashprovingkey_new() != 64689 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashratio_new() != 39493 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_decode() != 46681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_shielded() != 24211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_transparent() != 40355 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_unified() != 56662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashsaplingextractednotecommitment_new() != 40184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashsaplingmetadata_new() != 36534 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnode_from_cmu() != 29378 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnote_from_parts() != 3241 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnotevalue_from_raw() != 23308 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashscanrange_from_parts() != 14720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashscript_from_bytes() != 8889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtestgreedyinputselector_new() != 45241 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransaction_from_bytes() != 51056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransactionbuilder_new() != 65172 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_empty() != 62739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_from_uri() != 57836 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_new() != 17827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_decode() != 55219 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_from_public_key() != 35825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_from_script() != 29163 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtxid_from_bytes() != 481 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtxout_new() != 48394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtxversion_from_bytes() != 14907 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashtxversion_suggested_for_branch() != 60942 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedaddress_decode() != 57622 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedaddress_new() != 60718 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedfullviewingkey_decode() != 35783 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedfullviewingkey_new() != 56024 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedspendingkey_from_bytes() != 51407 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashunifiedspendingkey_from_seed() != 2426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashverifyingkey_new() != 26863 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashwalletdb_for_path() != 43172 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashwalletsummary_new() != 3775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashwallettransparentoutput_from_parts() != 12073 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashzip317feerule_non_standard() != 29630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashzip317feerule_standard() != 16827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_uniffi_zcash_checksum_constructor_zcashzip317singleoutputchangestrategy_new() != 48217 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
